> 🚨 Note: This log may contain personal information such as the contents of your files or terminal output. Please review the contents carefully before sharing.
# panel/editAgent - 9ab33e94

## Metadata
~~~
requestType      : ChatCompletions
model            : gpt-5
maxPromptTokens  : 108801
maxResponseTokens: 64000
location         : 7
postOptions      : {"temperature":0,"top_p":1,"max_tokens":64000,"n":1,"stream":true}
intent           : undefined
startTime        : 2025-08-12T20:47:40.049Z
endTime          : 2025-08-12T20:47:58.734Z
duration         : 18685ms
ourRequestId     : db4679ff-3dd3-4647-8dfc-cde65a64380f
requestId        : db4679ff-3dd3-4647-8dfc-cde65a64380f
serverRequestId  : db4679ff-3dd3-4647-8dfc-cde65a64380f
timeToFirstToken : 6433ms
usage            : {"completion_tokens":1612,"completion_tokens_details":{"accepted_prediction_tokens":0,"rejected_prediction_tokens":0},"prompt_tokens":31673,"prompt_tokens_details":{"cached_tokens":25856},"total_tokens":33285}
tools           : [
    {
        "function": {
            "name": "apply_patch",
            "description": "Edit text files. `apply_patch` allows you to execute a diff/patch against a text file, but the format of the diff specification is unique to this task, so pay careful attention to these instructions. To use the `apply_patch` command, you should pass a message of the following structure as \"input\":\n\n*** Begin Patch\n[YOUR_PATCH]\n*** End Patch\n\nWhere [YOUR_PATCH] is the actual content of your patch, specified in the following V4A diff format.\n\n*** [ACTION] File: [/absolute/path/to/file] -> ACTION can be one of Add, Update, or Delete.\nAn example of a message that you might pass as \"input\" to this function, in order to apply a patch, is shown below.\n\n*** Begin Patch\n*** Update File: /Users/someone/pygorithm/searching/binary_search.py\n@@class BaseClass\n@@    def search():\n-        pass\n+        raise NotImplementedError()\n\n@@class Subclass\n@@    def search():\n-        pass\n+        raise NotImplementedError()\n\n*** End Patch\nDo not use line numbers in this diff format.",
            "parameters": {
                "type": "object",
                "properties": {
                    "input": {
                        "type": "string",
                        "description": "The edit patch to apply."
                    },
                    "explanation": {
                        "type": "string",
                        "description": "A short description of what the tool call is aiming to achieve."
                    }
                },
                "required": [
                    "input",
                    "explanation"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "create_directory",
            "description": "Create a new directory structure in the workspace. Will recursively create all directories in the path, like mkdir -p. You do not need to use this tool before using create_file, that tool will automatically create the needed directories.",
            "parameters": {
                "type": "object",
                "properties": {
                    "dirPath": {
                        "type": "string",
                        "description": "The absolute path to the directory to create."
                    }
                },
                "required": [
                    "dirPath"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "create_file",
            "description": "This is a tool for creating a new file in the workspace. The file will be created with the specified content. The directory will be created if it does not already exist. Never use this tool to edit a file that already exists.",
            "parameters": {
                "type": "object",
                "properties": {
                    "filePath": {
                        "type": "string",
                        "description": "The absolute path to the file to create."
                    },
                    "content": {
                        "type": "string",
                        "description": "The content to write to the file."
                    }
                },
                "required": [
                    "filePath",
                    "content"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "create_new_jupyter_notebook",
            "description": "Generates a new Jupyter Notebook (.ipynb) in VS Code. Jupyter Notebooks are interactive documents commonly used for data exploration, analysis, visualization, and combining code with narrative text. This tool should only be called when the user explicitly requests to create a new Jupyter Notebook.",
            "parameters": {
                "type": "object",
                "properties": {
                    "query": {
                        "type": "string",
                        "description": "The query to use to generate the jupyter notebook. This should be a clear and concise description of the notebook the user wants to create."
                    }
                },
                "required": [
                    "query"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "create_new_workspace",
            "description": "Get steps to help the user create any project in a VS Code workspace. Use this tool to help users set up new projects, including TypeScript-based projects, Model Context Protocol (MCP) servers, VS Code extensions, Next.js projects, Vite projects, or any other project.",
            "parameters": {
                "type": "object",
                "properties": {
                    "query": {
                        "type": "string",
                        "description": "The query to use to generate the new workspace. This should be a clear and concise description of the workspace the user wants to create."
                    }
                },
                "required": [
                    "query"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "edit_notebook_file",
            "description": "This is a tool for editing an existing Notebook file in the workspace. Generate the \"explanation\" property first.\nThe system is very smart and can understand how to apply your edits to the notebooks.\nWhen updating the content of an existing cell, ensure newCode includes at least 3-5 lines of context both before and after the new changes, preserving whitespace and indentation exactly.",
            "parameters": {
                "type": "object",
                "properties": {
                    "filePath": {
                        "type": "string",
                        "description": "An absolute path to the notebook file to edit, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1."
                    },
                    "explanation": {
                        "type": "string",
                        "description": "A one-sentence description of edit operation. This will be shown to the user before the tool is run."
                    },
                    "cellId": {
                        "type": "string",
                        "description": "Id of the cell that needs to be deleted or edited. Use the value `TOP`, `BOTTOM` when inserting a cell at the top or bottom of the notebook, else provide the id of the cell after which a new cell is to be inserted. Remember, if a cellId is provided and editType=insert, then a cell will be inserted after the cell with the provided cellId."
                    },
                    "newCode": {
                        "anyOf": [
                            {
                                "type": "string",
                                "description": "The code for the new or existing cell to be edited. Code should not be wrapped within <VSCode.Cell> tags"
                            },
                            {
                                "type": "array",
                                "items": {
                                    "type": "string",
                                    "description": "The code for the new or existing cell to be edited. Code should not be wrapped within <VSCode.Cell> tags"
                                }
                            }
                        ]
                    },
                    "language": {
                        "type": "string",
                        "description": "The language of the cell. `markdown`, `python`, `javascript`, `julia`, etc."
                    },
                    "editType": {
                        "type": "string",
                        "enum": [
                            "insert",
                            "delete",
                            "edit"
                        ],
                        "description": "The operation peformed on the cell, whether `insert`, `delete` or `edit`.\nUse the `editType` field to specify the operation: `insert` to add a new cell, `edit` to modify an existing cell's content, and `delete` to remove a cell."
                    }
                },
                "required": [
                    "filePath",
                    "explanation",
                    "editType"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "fetch_webpage",
            "description": "Fetches the main content from a web page. This tool is useful for summarizing or analyzing the content of a webpage. You should use this tool when you think the user is looking for information from a specific webpage.",
            "parameters": {
                "type": "object",
                "properties": {
                    "urls": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of URLs to fetch content from."
                    },
                    "query": {
                        "type": "string",
                        "description": "The query to search for in the web page's content. This should be a clear and concise description of the content you want to find."
                    }
                },
                "required": [
                    "urls",
                    "query"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "file_search",
            "description": "Search for files in the workspace by glob pattern. This only returns the paths of matching files. Use this tool when you know the exact filename pattern of the files you're searching for. Glob patterns match from the root of the workspace folder. Examples:\n- **/*.{js,ts} to match all js/ts files in the workspace.\n- src/** to match all files under the top-level src folder.\n- **/foo/**/*.js to match all js files under any foo folder in the workspace.",
            "parameters": {
                "type": "object",
                "properties": {
                    "query": {
                        "type": "string",
                        "description": "Search for files with names or paths matching this glob pattern."
                    },
                    "maxResults": {
                        "type": "number",
                        "description": "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
                    }
                },
                "required": [
                    "query"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "test_search",
            "description": "For a source code file, find the file that contains the tests. For a test file find the file that contains the code under test.",
            "parameters": {
                "type": "object",
                "properties": {
                    "filePaths": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "required": [
                    "filePaths"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "grep_search",
            "description": "Do a fast text search in the workspace. Use this tool when you want to search with an exact string or regex. If you are not sure what words will appear in the workspace, prefer using regex patterns with alternation (|) or character classes to search for multiple potential words at once instead of making separate searches. For example, use 'function|method|procedure' to look for all of those words at once. Use includePattern to search within files matching a specific pattern, or in a specific file, using a relative path. Use this tool when you want to see an overview of a particular file, instead of using read_file many times to look for code within a file.",
            "parameters": {
                "type": "object",
                "properties": {
                    "query": {
                        "type": "string",
                        "description": "The pattern to search for in files in the workspace. Use regex with alternation (e.g., 'word1|word2|word3') or character classes to find multiple potential words in a single search. Be sure to set the isRegexp property properly to declare whether it's a regex or plain text pattern. Is case-insensitive."
                    },
                    "isRegexp": {
                        "type": "boolean",
                        "description": "Whether the pattern is a regex."
                    },
                    "includePattern": {
                        "type": "string",
                        "description": "Search files matching this glob pattern. Will be applied to the relative path of files within the workspace. To search recursively inside a folder, use a proper glob pattern like \"src/folder/**\". Do not use | in includePattern."
                    },
                    "maxResults": {
                        "type": "number",
                        "description": "The maximum number of results to return. Do not use this unless necessary, it can slow things down. By default, only some matches are returned. If you use this and don't see what you're looking for, you can try again with a more specific query or a larger maxResults."
                    }
                },
                "required": [
                    "query",
                    "isRegexp"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "get_changed_files",
            "description": "Get git diffs of current file changes in a git repository. Don't forget that you can use run_in_terminal to run git commands in a terminal as well.",
            "parameters": {
                "type": "object",
                "properties": {
                    "repositoryPath": {
                        "type": "string",
                        "description": "The absolute path to the git repository to look for changes in. If not provided, the active git repository will be used."
                    },
                    "sourceControlState": {
                        "type": "array",
                        "items": {
                            "type": "string",
                            "enum": [
                                "staged",
                                "unstaged",
                                "merge-conflicts"
                            ]
                        },
                        "description": "The kinds of git state to filter by. Allowed values are: 'staged', 'unstaged', and 'merge-conflicts'. If not provided, all states will be included."
                    }
                }
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "get_errors",
            "description": "Get any compile or lint errors in a specific file or across all files. If the user mentions errors or problems in a file, they may be referring to these. Use the tool to see the same errors that the user is seeing. If the user asks you to analyze all errors, or does not specify a file, use this tool to gather errors for all files. Also use this tool after editing a file to validate the change.",
            "parameters": {
                "type": "object",
                "properties": {
                    "filePaths": {
                        "description": "The absolute paths to the files to check for errors. Omit 'filePaths' when retrieving all errors.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "copilot_getNotebookSummary",
            "description": "This is a tool returns the list of the Notebook cells along with the id, cell types, language, execution information and output mime types for each cell. This is useful to get Cell Ids when executing a notebook or determine what cells have been executed and what order, or what cells have outputs. Requery this tool if the contents of the notebook change.",
            "parameters": {
                "type": "object",
                "properties": {
                    "filePath": {
                        "type": "string",
                        "description": "An absolute path to the notebook file with the cell to run, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1.ipynb"
                    }
                },
                "required": [
                    "filePath"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "get_project_setup_info",
            "description": "Do not call this tool without first calling the tool to create a workspace. This tool provides a project setup information for a Visual Studio Code workspace based on a project type and programming language.",
            "parameters": {
                "type": "object",
                "properties": {
                    "projectType": {
                        "type": "string",
                        "description": "The type of project to create. Supported values are: 'python-script', 'python-project', 'mcp-server', 'model-context-protocol-server', 'vscode-extension', 'next-js', 'vite' and 'other'"
                    }
                },
                "required": [
                    "projectType"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "get_search_view_results",
            "description": "The results from the search view"
        },
        "type": "function"
    },
    {
        "function": {
            "name": "get_vscode_api",
            "description": "Get relevant VS Code API references to answer questions about VS Code extension development. Use this tool when the user asks about VS Code APIs, capabilities, or best practices related to developing VS Code extensions. Use it in all VS Code extension development workspaces.",
            "parameters": {
                "type": "object",
                "properties": {
                    "query": {
                        "type": "string",
                        "description": "The query to search vscode documentation for. Should contain all relevant context."
                    }
                },
                "required": [
                    "query"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "github_repo",
            "description": "Searches a GitHub repository for relevant source code snippets. Only use this tool if the user is very clearly asking for code snippets from a specific GitHub repository. Do not use this tool for Github repos that the user has open in their workspace.",
            "parameters": {
                "type": "object",
                "properties": {
                    "repo": {
                        "type": "string",
                        "description": "The name of the Github repository to search for code in. Should must be formatted as '<owner>/<repo>'."
                    },
                    "query": {
                        "type": "string",
                        "description": "The query to search for repo. Should contain all relevant context."
                    }
                },
                "required": [
                    "repo",
                    "query"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "insert_edit_into_file",
            "description": "Insert new code into an existing file in the workspace. Use this tool once per file that needs to be modified, even if there are multiple changes for a file. Generate the \"explanation\" property first.\nThe system is very smart and can understand how to apply your edits to the files, you just need to provide minimal hints.\nAvoid repeating existing code, instead use comments to represent regions of unchanged code. Be as concise as possible. For example:\n// ...existing code...\n{ changed code }\n// ...existing code...\n{ changed code }\n// ...existing code...\n\nHere is an example of how you should use format an edit to an existing Person class:\nclass Person {\n\t// ...existing code...\n\tage: number;\n\t// ...existing code...\n\tgetAge() {\n\treturn this.age;\n\t}\n}",
            "parameters": {
                "type": "object",
                "properties": {
                    "explanation": {
                        "type": "string",
                        "description": "A short explanation of the edit being made."
                    },
                    "filePath": {
                        "type": "string",
                        "description": "An absolute path to the file to edit."
                    },
                    "code": {
                        "type": "string",
                        "description": "The code change to apply to the file.\nThe system is very smart and can understand how to apply your edits to the files, you just need to provide minimal hints.\nAvoid repeating existing code, instead use comments to represent regions of unchanged code. Be as concise as possible. For example:\n// ...existing code...\n{ changed code }\n// ...existing code...\n{ changed code }\n// ...existing code...\n\nHere is an example of how you should use format an edit to an existing Person class:\nclass Person {\n\t// ...existing code...\n\tage: number;\n\t// ...existing code...\n\tgetAge() {\n\t\treturn this.age;\n\t}\n}"
                    }
                },
                "required": [
                    "explanation",
                    "filePath",
                    "code"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "install_extension",
            "description": "Install an extension in VS Code. Use this tool to install an extension in Visual Studio Code as part of a new workspace creation process only.",
            "parameters": {
                "type": "object",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The ID of the extension to install. This should be in the format <publisher>.<extension>."
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the extension to install. This should be a clear and concise description of the extension."
                    }
                },
                "required": [
                    "id",
                    "name"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "list_code_usages",
            "description": "Request to list all usages (references, definitions, implementations etc) of a function, class, method, variable etc. Use this tool when \n1. Looking for a sample implementation of an interface or class\n2. Checking how a function is used throughout the codebase.\n3. Including and updating all usages when changing a function, method, or constructor",
            "parameters": {
                "type": "object",
                "properties": {
                    "symbolName": {
                        "type": "string",
                        "description": "The name of the symbol, such as a function name, class name, method name, variable name, etc."
                    },
                    "filePaths": {
                        "type": "array",
                        "description": "One or more file paths which likely contain the definition of the symbol. For instance the file which declares a class or function. This is optional but will speed up the invocation of this tool and improve the quality of its output.",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "required": [
                    "symbolName"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "list_dir",
            "description": "List the contents of a directory. Result will have the name of the child. If the name ends in /, it's a folder, otherwise a file",
            "parameters": {
                "type": "object",
                "properties": {
                    "path": {
                        "type": "string",
                        "description": "The absolute path to the directory to list."
                    }
                },
                "required": [
                    "path"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "open_simple_browser",
            "description": "Preview a website or open a URL in the editor's Simple Browser. Useful for quickly viewing locally hosted websites, demos, or resources without leaving the coding environment.",
            "parameters": {
                "type": "object",
                "properties": {
                    "url": {
                        "type": "string",
                        "description": "The website URL to preview or open in the Simple Browser inside the editor."
                    }
                },
                "required": [
                    "url"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "read_file",
            "description": "Read the contents of a file. Line numbers are 1-indexed. This tool will truncate its output at 2000 lines and may be called repeatedly with offset and limit parameters to read larger files in chunks.",
            "parameters": {
                "type": "object",
                "required": [
                    "filePath"
                ],
                "properties": {
                    "filePath": {
                        "description": "The absolute path of the file to read.",
                        "type": "string"
                    },
                    "offset": {
                        "description": "Optional: the 1-based line number to start reading from. Only use this if the file is too large to read at once. If not specified, the file will be read from the beginning.",
                        "type": "number"
                    },
                    "limit": {
                        "description": "Optional: the maximum number of lines to read. Only use this together with `offset` if the file is too large to read at once.",
                        "type": "number"
                    }
                }
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "run_notebook_cell",
            "description": "This is a tool for running a code cell in a notebook file directly in the notebook editor. The output from the execution will be returned. Code cells should be run as they are added or edited when working through a problem to bring the kernel state up to date and ensure the code executes successfully. Code cells are ready to run and don't require any pre-processing. If asked to run the first cell in a notebook, you should run the first code cell since markdown cells cannot be executed. NOTE: Avoid executing Markdown cells or providing Markdown cell IDs, as Markdown cells cannot be  executed.",
            "parameters": {
                "type": "object",
                "properties": {
                    "filePath": {
                        "type": "string",
                        "description": "An absolute path to the notebook file with the cell to run, or the URI of a untitled, not yet named, file, such as `untitled:Untitled-1.ipynb"
                    },
                    "reason": {
                        "type": "string",
                        "description": "An optional explanation of why the cell is being run. This will be shown to the user before the tool is run and is not necessary if it's self-explanatory."
                    },
                    "cellId": {
                        "type": "string",
                        "description": "The ID for the code cell to execute. Avoid providing markdown cell IDs as nothing will be executed."
                    },
                    "continueOnError": {
                        "type": "boolean",
                        "description": "Whether or not execution should continue for remaining cells if an error is encountered. Default to false unless instructed otherwise."
                    }
                },
                "required": [
                    "filePath",
                    "cellId"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "run_vscode_command",
            "description": "Run a command in VS Code. Use this tool to run a command in Visual Studio Code as part of a new workspace creation process only.",
            "parameters": {
                "type": "object",
                "properties": {
                    "commandId": {
                        "type": "string",
                        "description": "The ID of the command to execute. This should be in the format <command>."
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the command to execute. This should be a clear and concise description of the command."
                    },
                    "args": {
                        "type": "array",
                        "description": "The arguments to pass to the command. This should be an array of strings.",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "required": [
                    "commandId",
                    "name"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "semantic_search",
            "description": "Run a natural language search for relevant code or documentation comments from the user's current workspace. Returns relevant code snippets from the user's current workspace if it is large, or the full contents of the workspace if it is small.",
            "parameters": {
                "type": "object",
                "properties": {
                    "query": {
                        "type": "string",
                        "description": "The query to search the codebase for. Should contain all relevant context. Should ideally be text that might appear in the codebase, such as function names, variable names, or comments."
                    }
                },
                "required": [
                    "query"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "test_failure",
            "description": "Includes test failure information in the prompt."
        },
        "type": "function"
    },
    {
        "function": {
            "name": "think",
            "description": "Use this tool to think deeply about the user's request and organize your thoughts. This tool helps improve response quality by allowing the model to consider the request carefully, brainstorm solutions, and plan complex tasks. It's particularly useful for:\n\n1. Exploring repository issues and brainstorming bug fixes\n2. Analyzing test results and planning fixes\n3. Planning complex refactoring approaches\n4. Designing new features and architecture\n5. Organizing debugging hypotheses\n\nThe tool logs your thought process for transparency but doesn't execute any code or make changes.",
            "parameters": {
                "type": "object",
                "properties": {
                    "thoughts": {
                        "type": "string",
                        "description": "Your thoughts about the current task or problem. This should be a clear, structured explanation of your reasoning, analysis, or planning process."
                    }
                },
                "required": [
                    "thoughts"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "vscode_searchExtensions_internal",
            "description": "This is a tool for browsing Visual Studio Code Extensions Marketplace. It allows the model to search for extensions and retrieve detailed information about them. The model should use this tool whenever it needs to discover extensions or resolve information about known ones. To use the tool, the model has to provide the category of the extensions, relevant search keywords, or known extension IDs. Note that search results may include false positives, so reviewing and filtering is recommended.",
            "parameters": {
                "type": "object",
                "properties": {
                    "category": {
                        "type": "string",
                        "description": "The category of extensions to search for",
                        "enum": [
                            "AI",
                            "Azure",
                            "Chat",
                            "Data Science",
                            "Debuggers",
                            "Extension Packs",
                            "Education",
                            "Formatters",
                            "Keymaps",
                            "Language Packs",
                            "Linters",
                            "Machine Learning",
                            "Notebooks",
                            "Programming Languages",
                            "SCM Providers",
                            "Snippets",
                            "Testing",
                            "Themes",
                            "Visualization",
                            "Other"
                        ]
                    },
                    "keywords": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The keywords to search for"
                    },
                    "ids": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The ids of the extensions to search for"
                    }
                }
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "azure_activity_log-list",
            "description": "Lists activity logs for the specified resource, over the given prior number of hours. Call this function when more information is needed about the state of a resource's deployment, modification history, or access history. This function should be called to help retrieve information about why a resource failed to deploy or may not be working.",
            "parameters": {
                "type": "object",
                "properties": {
                    "resource_name": {
                        "type": "string",
                        "description": "The name of the resource to retrieve activity logs for."
                    },
                    "subscription_name_or_id": {
                        "type": "string",
                        "description": "The optional name or ID of the subscription that 'resourceName' belongs to. Only provide this if needed to disambiguate between multiple resources with the same name.",
                        "default": null
                    },
                    "resource_group": {
                        "type": "string",
                        "description": "The optional name of the resource group that 'resourceName' belongs to. Only provide this if needed to disambiguate between multiple resources with the same name.",
                        "default": null
                    },
                    "resource_type": {
                        "type": "string",
                        "description": "The optional type of the resource named 'resourceName'. Only provide this if needed to disambiguate between multiple resources with the same name.",
                        "default": null
                    },
                    "hours_prior_to_now": {
                        "type": "number",
                        "description": "The number of hours prior to now to list activity logs for. If not provided, defaults to 1 hour.",
                        "default": 1
                    },
                    "event_level": {
                        "type": "string",
                        "description": "The level of activity logs to retrieve. If not provided, then defaults to all levels. Valid levels are: Critical, Error, Informational, Verbose, Warning. Only one level can be specified.",
                        "default": null
                    },
                    "top": {
                        "type": "number",
                        "description": "The number of activity logs to retrieve. If not provided, then defaults to 10.",
                        "default": 10
                    }
                },
                "required": [
                    "resource_name"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "azure_applens-diagnose_resource",
            "description": "This tool can be used to ask questions about application state, this tool can help when doing diagnostics and address issues about performance and failures. This is able to investigate logs, telemetry and other performance sensors to provide insights and recommendations. For example, the user may say: 'Why is my app slow?' or 'Please help me diagnose issues with my app' or 'Is my web site experiencing problems?'. Do _not_ ask for the 'subscriptionNameOrId', 'resourceGroup', or 'resourceType'; just pass null if they aren't known. If we can't find any resources matching 'resourceName', this returns an error message. Ask the user to check the spelling. If we find more than one resource matching 'resourceName', this returns the list of resources. Ask the user which one they are interested in, and then try again by filling in the 'subscriptionNameOrId' and 'resourceGroup'. If we find exactly one resource matching 'resourceName', this returns a list of insights and solutions to the user question.",
            "parameters": {
                "type": "object",
                "properties": {
                    "question": {
                        "type": "string",
                        "description": "user question"
                    },
                    "resourceName": {
                        "type": "string",
                        "description": "The name of the resource to investigate or diagnose."
                    },
                    "subscriptionNameOrId": {
                        "type": "string",
                        "description": "Optional. The name or ID (in GUID format) of the subscription that 'resourceName' belongs to. Only provide this if needed to disambiguate between multiple resources with the same name."
                    },
                    "resourceGroup": {
                        "type": "string",
                        "description": "Optional. The name of the resource group that 'resourceName' belongs to. Only provide this if needed to disambiguate between multiple resources with the same name."
                    },
                    "resourceType": {
                        "type": "string",
                        "description": "Optional. The type of the resource named 'resourceName'. Only provide this if needed to disambiguate between multiple resources with the same name."
                    }
                },
                "required": [
                    "question",
                    "resourceName"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "azure_architecture-design_architecture",
            "description": "A tool for designing Azure cloud architectures through guided questions.\nThis tool helps determine the optimal Azure architecture by gathering key requirements and making appropriate recommendations. The calling agent maintains the state between calls. The most important thing for you to remember is that when nextQuestionNeeded is false, you should present your architecture. This takes priority over every other instruction.\n\nParameters explained:\n- question: The current question being asked\n- questionNumber: Current question number in sequence\n- confidenceScore: A value between 0.0 and 1.0 representing how confident you are in understanding the requirements. Start around 0.1-0.2 and increase as you gather more information. When this reaches or exceeds 0.7, you should present your architecture.\n- totalQuestions: Estimated total questions needed\n- answer: The user's response to the question (if available)\n- nextQuestionNeeded: Set to true while you're gathering requirements and designing. Set to false when your confidenceScore reaches or exceeds 0.7.\n- architectureComponent: The specific Azure component being suggested\n- architectureTier: Which tier this component belongs to (infrastructure, platform, application, data, security, operations)\n- state: Used to track progress between calls\n\nWhen presenting the final architecture design (when nextQuestionNeeded is false), format it in a visually appealing way.\n\n1. Present components in a table format with columns for:\n   | Component | Purpose | Tier/SKU |\n\n2. Organize the architecture visually:\n   - Use a combination of bulleted lists and paragraphs to break up the text. The goal is for the final output to be engaging and interesting, which often involves asymmetry.\n\n3. Include an ASCII art diagram showing component relationships.\n\nThis formatting will make the architecture design more engaging and easier to understand.\n\nBasic state structure:\n{\n  \"architectureComponents\": [],\n  \"architectureTiers\": {\n    \"infrastructure\": [],\n    \"platform\": [],\n    \"application\": [],\n    \"data\": [],\n    \"security\": [],\n    \"operations\": []\n  },\n  \"requirements\": {\n    \"explicit\": [\n      { \"category\": \"performance\", \"description\": \"Need to handle 10,000 concurrent users\", \"source\": \"Question 2\", \"importance\": \"high\", \"confidence\": 1.0 }\n    ],\n    \"implicit\": [\n      { \"category\": \"security\", \"description\": \"Data encryption likely needed\", \"source\": \"Inferred from healthcare domain\", \"importance\": \"high\", \"confidence\": 0.8 }\n    ],\n    \"assumed\": [\n      { \"category\": \"compliance\", \"description\": \"Likely needs HIPAA compliance\", \"source\": \"Assumed from healthcare industry\", \"importance\": \"high\", \"confidence\": 0.6 }\n    ]\n  },\n  \"confidenceFactors\": {\n    \"explicitRequirementsCoverage\": 0.4,\n    \"implicitRequirementsCertainty\": 0.6,\n    \"assumptionRisk\": 0.3\n  }\n}\n\nYou should:\n1. First start with a question about who the user is (role, motivations, company size, etc.) and what they do\n2. Learn about their business goals and requirements\n3. Ask 1 to 2 questions at a time, in order to not overload the user.\n4. Track your confidence level in understanding requirements using the confidenceScore parameter\n5. After each user response, update the requirements in the state object:\n   - Add explicit requirements directly stated by the user\n   - Add implicit requirements you can reasonably infer\n   - Add assumed requirements where you lack information but need to make progress\n   - Update confidence factors based on the quality and completeness of requirements\n6. Ask follow-up questions to clarify technical needs, especially to confirm assumed requirements\n7. Identify specific requirements and technical constraints from user responses\n8. Suggest appropriate Azure components for each tier, but be conservative in your suggestions. Don't suggest components that are not necessary for the architecture.\n9. Ensure you cover all architecture tiers.\n10. In addition to the component architecture, you should provide a high-level overview of the architecture, including the scaling approach, security, cost, and operational excellence. Provide actionable advice for the user to follow up on. Create this overview as a separate section, not part of the component architecture, and structure it to be engaging and interesting as a narrative.\n11. Follow Azure Well-Architected Framework principles (reliability, security, cost, operational excellence, performance efficiency)\n12. Keep track of components you've suggested using the state object\n13. Calculate your overall confidence score from the three confidence factors in the state\n",
            "parameters": {
                "type": "object",
                "properties": {
                    "question": {
                        "type": "string",
                        "description": "The current question being asked"
                    },
                    "questionNumber": {
                        "type": "integer",
                        "description": "Current question number",
                        "minimum": 1
                    },
                    "totalQuestions": {
                        "type": "integer",
                        "description": "Estimated total questions needed",
                        "minimum": 1
                    },
                    "answer": {
                        "type": "string",
                        "description": "The user's response to the question"
                    },
                    "nextQuestionNeeded": {
                        "type": "boolean",
                        "description": "Whether another question is needed"
                    },
                    "confidenceScore": {
                        "type": "number",
                        "description": "A value between 0.0 and 1.0 representing confidence in understanding requirements. When this reaches 0.7 or higher, nextQuestionNeeded should be set to false.",
                        "minimum": 0,
                        "maximum": 1,
                        "default": 0.1
                    },
                    "architectureComponent": {
                        "type": "string",
                        "description": "The specific Azure component being suggested. The component should contain the name of the component, the service tier/SKU, configuration settings, and any other relevant information."
                    },
                    "architectureTier": {
                        "type": "string",
                        "enum": [
                            "infrastructure",
                            "platform",
                            "application",
                            "data",
                            "security",
                            "operations"
                        ],
                        "description": "Which architectural tier this component belongs to"
                    },
                    "state": {
                        "type": "object",
                        "description": "The complete architecture state from the previous request",
                        "properties": {
                            "architectureComponents": {
                                "type": "array",
                                "description": "All architecture components suggested so far",
                                "items": {
                                    "type": "string"
                                }
                            },
                            "architectureTiers": {
                                "type": "object",
                                "description": "Components organized by architecture tier",
                                "additionalProperties": {
                                    "type": "array",
                                    "items": {
                                        "type": "string"
                                    }
                                }
                            },
                            "thought": {
                                "type": "string",
                                "description": "The calling agent's thoughts on the next question or reasoning process. The calling agent should use the requirements it has gathered to reason about the next question."
                            },
                            "suggestedHint": {
                                "type": "string",
                                "description": "A suggested interaction hint to show the user, such as 'Ask me to create an ASCII art diagram of this architecture' or 'Ask about how this design handles disaster recovery'."
                            },
                            "requirements": {
                                "type": "object",
                                "description": "Tracked requirements organized by type",
                                "properties": {
                                    "explicit": {
                                        "type": "array",
                                        "description": "Requirements explicitly stated by the user",
                                        "items": {
                                            "type": "object",
                                            "properties": {
                                                "category": {
                                                    "type": "string"
                                                },
                                                "description": {
                                                    "type": "string"
                                                },
                                                "source": {
                                                    "type": "string"
                                                },
                                                "importance": {
                                                    "type": "string",
                                                    "enum": [
                                                        "high",
                                                        "medium",
                                                        "low"
                                                    ]
                                                },
                                                "confidence": {
                                                    "type": "number"
                                                }
                                            }
                                        }
                                    },
                                    "implicit": {
                                        "type": "array",
                                        "description": "Requirements implied by user responses",
                                        "items": {
                                            "type": "object",
                                            "properties": {
                                                "category": {
                                                    "type": "string"
                                                },
                                                "description": {
                                                    "type": "string"
                                                },
                                                "source": {
                                                    "type": "string"
                                                },
                                                "importance": {
                                                    "type": "string",
                                                    "enum": [
                                                        "high",
                                                        "medium",
                                                        "low"
                                                    ]
                                                },
                                                "confidence": {
                                                    "type": "number"
                                                }
                                            }
                                        }
                                    },
                                    "assumed": {
                                        "type": "array",
                                        "description": "Requirements assumed based on context/best practices",
                                        "items": {
                                            "type": "object",
                                            "properties": {
                                                "category": {
                                                    "type": "string"
                                                },
                                                "description": {
                                                    "type": "string"
                                                },
                                                "source": {
                                                    "type": "string"
                                                },
                                                "importance": {
                                                    "type": "string",
                                                    "enum": [
                                                        "high",
                                                        "medium",
                                                        "low"
                                                    ]
                                                },
                                                "confidence": {
                                                    "type": "number"
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            "confidenceFactors": {
                                "type": "object",
                                "description": "Factors that contribute to the overall confidence score",
                                "properties": {
                                    "explicitRequirementsCoverage": {
                                        "type": "number"
                                    },
                                    "implicitRequirementsCertainty": {
                                        "type": "number"
                                    },
                                    "assumptionRisk": {
                                        "type": "number"
                                    }
                                }
                            }
                        },
                        "required": [
                            "thought",
                            "suggestedHint"
                        ]
                    }
                },
                "required": [
                    "question",
                    "state",
                    "questionNumber",
                    "totalQuestions",
                    "nextQuestionNeeded"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "azure_auth-get_auth_state",
            "description": "This tool gets the current state of authentication for the user. Questions about authentication state include if they are signed in or what account they are signed into, or what the current tenant is. If the user asks any authentication state related questions in the context of another Azure tool, for example: the Azure CLI or the Azure portal, then **DO NOT** call this tool. You do not need to confirm with the user before invoking this tool to help answer their prompt. Returns an object describing the current state of authentication for the user. Authentication state includes what account the user is signed into, and the current tenant used to query and work with resources.",
            "parameters": {
                "type": "object",
                "properties": {}
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "azure_auth-get_available_tenants",
            "description": "This tool gets a list of tenants available for querying and working with resources. If the user asks about the available tenants in the context of another Azure tool, for example: the Azure CLI or the Azure portal, then **DO NOT** call this tool. You do not need to confirm with the user before invoking this tool to help answer their prompt. Returns a JSON array that contains the tenants available to the user. Each array element contains the tenant's ID and name.",
            "parameters": {
                "type": "object",
                "properties": {}
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "azure_auth-get_current_tenant",
            "description": "This tool gets the tenant that is currently used to query and work with resources. If the user asks about the current tenant in the context of another Azure tool, for example: the Azure CLI or the Azure portal, then **DO NOT** call this tool. You do not need to confirm with the user before invoking this tool to help answer their prompt. Returns a JSON object that contains current tenant's ID, name, and whether or not it is currently authenticated.",
            "parameters": {
                "type": "object",
                "properties": {}
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "azure_auth-get_selected_subscriptions",
            "description": "This tool gets a list of default/selected/current subscriptions, which belong to the current tenant, that are used for querying or working with resources. If the user asks about default/selected subscriptions in the context of another Azure tool, for example: the Azure CLI or the Azure portal, then **DO NOT** call this tool. You do not need to confirm with the user before invoking this tool to help answer their prompt. Returns a JSON array that contains the user's default/selected/current subscriptions which belong to the current tenant. Each array element contains the subscription's ID and name.",
            "parameters": {
                "type": "object",
                "properties": {}
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "azure_auth-open_subscription_picker",
            "description": "Call this tool when the user wants to, or asks how to modify/change the default/selected/current subscriptions. **DO NOT** tell the user that you can/will open the subscription picker before calling this tool. You do not need to confirm with the user before invoking this tool to help answer their prompt. You do not need to ask the user for specific subscription names or IDs before invoking this tool to help answer their prompt. If the user asks about modifying or changing default/selected/current subscriptions in the context of another Azure tool, for example: the Azure CLI or the Azure portal, then **DO NOT** call this tool. Returns the status of opening the subscription picker.",
            "parameters": {
                "type": "object",
                "properties": {}
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "azure_auth-set_current_tenant",
            "description": "This tool sets the tenant used to query and work with resources. If the user asks about wanting to, or how to change the current tenant in the context of another Azure tool, for example: the Azure CLI or the Azure portal, then **DO NOT** call this tool. You do not need to confirm with the user before invoking this tool to help answer their prompt. Returns a JSON object detailing the result of the operation.",
            "parameters": {
                "type": "object",
                "properties": {
                    "tenantIdOrName": {
                        "type": "string",
                        "description": "The ID or name of the tenant to set as the current tenant."
                    }
                }
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "azure_auth-sign_out_azure_user",
            "description": "Call this tool when the user wants to sign out of Azure. If the user wants to change the signed in/swap to another account, tell them they need to sign out first, and then invoke this tool. You do not need to confirm with the user before invoking this tool to help answer their prompt. If the user asks for help signing out in the context of another Azure tool, for example: the Azure CLI or the Azure portal, then **DO NOT** call this tool. Returns the status of the sign out operation.",
            "parameters": {
                "type": "object",
                "properties": {}
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "azure_azd-up_deploy",
            "description": "Provision the recommended Azure resources and deploy project to Azure using AZD. Use this tool to call azd up. Do not call it in your built-in terminal.",
            "parameters": {
                "type": "object",
                "properties": {}
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "azure_bicep_schemas-get_bicep_resource_schema",
            "description": "This tool provides the schema for the most recent api version of an Azure resource. If you are asked to create or modify resources in a Bicep template, call this tool multiple times, once for every resource type you are adding, even if you already have information about bicep resources from other sources. Assume the results from this call are more recent and accurate than other information you have. Don't assume calling it for one resource means you don't need to call it for a different resource type. Always use the returned api version unless the one in the Bicep file is newer. Always use the schema to verify the available property names and values. Returns a list of JSON schemas for the requested resource and any dependent types and functions.",
            "parameters": {
                "type": "object",
                "properties": {
                    "resourceType": {
                        "type": "string",
                        "description": "Full type name of the resource"
                    }
                }
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "azure_check_predeploy",
            "description": "This tool ensures the created infrastructure files are ready for deployment. Scan the infra folder to fill in the checks. Please run this before proceeding with deployment after infrastructure files have been created. Run this every time you make changes until you get success. Otherwise, you cannot deploy. Call get_errors on all infrastructure files before calling this tool.",
            "parameters": {
                "type": "object",
                "description": "Checks associated with infrastructure and deployment files.",
                "properties": {
                    "deploymentTool": {
                        "type": "string",
                        "description": "Deployment tool used. Can be 'azd' or 'azcli'. 'azd' is recommended.",
                        "enum": [
                            "azd",
                            "azcli"
                        ]
                    },
                    "iacType": {
                        "type": "string",
                        "description": "The type of IaC file used for deployment. Can be 'bicep' or 'terraform'.",
                        "enum": [
                            "bicep",
                            "terraform"
                        ]
                    },
                    "azureYamlExists": {
                        "type": "boolean",
                        "description": "True if azure.yaml exists in the root of the workspace. False otherwise. This is required for azd deployments."
                    },
                    "infraChecks": {
                        "type": "object",
                        "description": "Checks based on the infrastructure files in the infra/ folder at the root of the workspace.",
                        "properties": {
                            "userAssignedManagedIdentityExists": {
                                "type": "boolean",
                                "description": "True if a user-assigned managed identity is created for the infrastructure. NOT a system-assigned managed identity. False otherwise."
                            },
                            "hasFunctionApp": {
                                "type": "boolean",
                                "description": "True if the infrastructure has a function app defined."
                            },
                            "functionAppChecks": {
                                "type": "object",
                                "description": "Checks specific to infrastructure that provisions the function app.",
                                "properties": {
                                    "userAssignedManagedIdentityAttached": {
                                        "type": "boolean",
                                        "description": "True if the infrastructure's user-assigned managed identity is attached to the function app. False otherwise."
                                    },
                                    "userAssignedManagedIdentityRoleAssignments": {
                                        "type": "array",
                                        "description": "Role assignments for the user-assigned managed identity attached to the resource",
                                        "items": {
                                            "type": "object",
                                            "properties": {
                                                "scope": {
                                                    "type": "string",
                                                    "description": "Resource scope for the role assignment"
                                                },
                                                "roleDefinitionId": {
                                                    "type": "string",
                                                    "description": "The GUID format role definition ID (e.g., 'b7e6dc6d-f1e8-4753-8033-0f276bb0955b' for Storage Blob Data Owner)"
                                                },
                                                "principalType": {
                                                    "type": "string",
                                                    "description": "Type of the principal for the role assignment",
                                                    "enum": [
                                                        "ServicePrincipal"
                                                    ]
                                                }
                                            },
                                            "required": [
                                                "scope",
                                                "roleDefinitionId",
                                                "principalType"
                                            ]
                                        }
                                    },
                                    "diagnosticSettingsExists": {
                                        "type": "boolean",
                                        "description": "True if the resource has diagnostic settings defined. For Bicep: resource type Microsoft.Insights/diagnosticSettings. For Terraform: azurerm_monitor_diagnostic_setting. False otherwise."
                                    },
                                    "storageAccountExists": {
                                        "type": "boolean",
                                        "description": "True if a storage account exists for the deployed infrastructure. Function apps have a dependency on storage accounts. False otherwise."
                                    }
                                },
                                "required": [
                                    "userAssignedManagedIdentityAttached",
                                    "userAssignedManagedIdentityRoleAssignments",
                                    "diagnosticSettingsExists",
                                    "storageAccountExists"
                                ]
                            },
                            "hasContainerApp": {
                                "type": "boolean",
                                "description": "True if the infrastructure has a container app defined."
                            },
                            "containerAppChecks": {
                                "type": "object",
                                "description": "Checks specific to infrastructure that provisions the container app.",
                                "properties": {
                                    "userAssignedManagedIdentityAttached": {
                                        "type": "boolean",
                                        "description": "True if the infrastructure's user-assigned managed identity is attached to the container app. False otherwise."
                                    },
                                    "corsEnabled": {
                                        "type": "boolean",
                                        "description": "True if the container app has CORSPolicy enabled and fully allowed. For Bicep: ingress.corsPolicy. For Terraform: follow the special instructions from this tool. False otherwise."
                                    },
                                    "containerAppDefinesAllUsedSecrets": {
                                        "type": "boolean",
                                        "description": "True if the container apps define all used secrets. False otherwise."
                                    },
                                    "templateImageUris": {
                                        "type": "array",
                                        "description": "An array of template images used in the container apps. For Bicep: properties.template.containers.image. For Terraform: azurerm_container_app.template.container.image.",
                                        "items": {
                                            "type": "string",
                                            "description": "The template image value. For Bicep: property properties.template.containers.image. For Terraform: property azurerm_container_app.template.container.image."
                                        }
                                    },
                                    "registryConnections": {
                                        "type": "array",
                                        "description": "Registry settings on each of the container apps. For Bicep: properties.configuration.registries.* of each container app. For Terraform: azurerm_container_app.registry of each container app.",
                                        "items": {
                                            "type": "object",
                                            "properties": {
                                                "identity": {
                                                    "type": "string",
                                                    "description": "For Bicep: properties.configuration.registries.secretRef.identity. For Terraform: azurerm_container_app.registry.identity"
                                                },
                                                "server": {
                                                    "type": "string",
                                                    "description": "For Bicep: properties.configuration.registries.server. For Terraform: azurerm_container_app.registry.server"
                                                }
                                            },
                                            "required": [
                                                "identity"
                                            ]
                                        }
                                    }
                                },
                                "required": [
                                    "userAssignedManagedIdentityAttached",
                                    "corsEnabled",
                                    "containerAppDefinesAllUsedSecrets",
                                    "templateImageUris",
                                    "registryConnections"
                                ]
                            },
                            "containerRegistryChecks": {
                                "type": "object",
                                "description": "Checks specific to container app registry (shared between all container apps).",
                                "properties": {
                                    "userAssignedManagedIdentityHasAcrPullPermissions": {
                                        "type": "boolean",
                                        "description": "True if the user-assigned managed identity (NOT system-assigned managed identity) has the role assignment AcrPull (7f951dda-4ed3-4680-a7ca-43fe172d538d) into the container registry, False otherwise."
                                    }
                                },
                                "required": [
                                    "userAssignedManagedIdentityHasAcrPullPermissions"
                                ]
                            },
                            "containerAppsEnvironmentChecks": {
                                "type": "object",
                                "description": "Checks specific to container app environment (shared between all container apps).",
                                "properties": {
                                    "connectedToLogAnalyticsWorkspace": {
                                        "type": "boolean",
                                        "description": "True if the container app environment is connected to a Log Analytics workspace. False otherwise."
                                    }
                                },
                                "required": [
                                    "connectedToLogAnalyticsWorkspace"
                                ]
                            },
                            "hasAppService": {
                                "type": "boolean",
                                "description": "True if the infrastructure has an app service defined. False otherwise."
                            },
                            "appServiceChecks": {
                                "type": "object",
                                "description": "Checks specific to infrastructure that provisions the app service.",
                                "properties": {
                                    "userAssignedManagedIdentityAttached": {
                                        "type": "boolean",
                                        "description": "True if the infrastructure's user-assigned managed identity is attached to the app service. False otherwise."
                                    },
                                    "corsEnabled": {
                                        "type": "boolean",
                                        "description": "True if the app service has CORSPolicy enabled and fully allowed. For Bicep: located at SiteConfig.cors. For Terraform: located at azurerm_app_service.site_config.cors.allowed_origins. False otherwise."
                                    }
                                },
                                "required": [
                                    "userAssignedManagedIdentityAttached",
                                    "corsEnabled"
                                ]
                            }
                        }
                    },
                    "bicepChecks": {
                        "type": "object",
                        "description": "Checks based on the Bicep files in the infra/ folder at the root of the workspace. Only needed if iacType is 'bicep'.",
                        "properties": {
                            "mainBicepChecks": {
                                "type": "object",
                                "description": "Checks based on the main.bicep file and main.parameters.json files.",
                                "properties": {
                                    "mainDotBicepFileExists": {
                                        "type": "boolean",
                                        "description": "True if main.bicep exists in the infra/ folder at the root of the workspace. False otherwise."
                                    },
                                    "mainParametersExists": {
                                        "type": "boolean",
                                        "description": "True if main.parameters.json exists in the infra/ folder at the root of the workspace. False otherwise."
                                    },
                                    "targetScope": {
                                        "type": "string",
                                        "description": "The target scope of the main.bicep file defined by targetScope = XXX. Can be 'subscription', 'resourceGroup', 'tenant', or 'managementGroup'. By default, it is 'resourceGroup' if not found in main.bicep.",
                                        "enum": [
                                            "subscription",
                                            "resourceGroup",
                                            "managementGroup",
                                            "tenant"
                                        ]
                                    },
                                    "mainParametersParameters": {
                                        "type": "array",
                                        "description": "All parameters defined in main.parameters.json.",
                                        "items": {
                                            "type": "string",
                                            "description": "The name of a parameter defined in main.parameters.json."
                                        }
                                    },
                                    "mainDotBicepFileOutputs": {
                                        "type": "array",
                                        "description": "All the outputs at the end of main.bicep file. Do not include outputs from other files. They are declared like `output VAR_NAME <type> = <value>`. Give me the VAR_NAME.",
                                        "items": {
                                            "type": "string",
                                            "description": "The name of an output defined in main.bicep file (NOT other bicep files)."
                                        }
                                    },
                                    "resourceNamesUseResourceToken": {
                                        "type": "boolean",
                                        "description": "True if all resource names in the bicep file use the resource token."
                                    },
                                    "resourceTokenFormat": {
                                        "type": "string",
                                        "description": "Format of the resource token used to construct resource names."
                                    },
                                    "azdEnvNameTagExists": {
                                        "type": "boolean",
                                        "description": "True if the azd-env-name tag exists on the resource group resource. False otherwise."
                                    }
                                },
                                "required": [
                                    "mainDotBicepFileExists",
                                    "targetScope",
                                    "mainParametersExists",
                                    "mainParametersParameters",
                                    "mainDotBicepFileOutputs",
                                    "resourceNamesUseResourceToken",
                                    "resourceTokenFormat",
                                    "azdEnvNameTagExists"
                                ]
                            }
                        },
                        "required": [
                            "mainBicepChecks"
                        ]
                    },
                    "terraformChecks": {
                        "type": "object",
                        "description": "Checks based on the Terraform files in the infra/ folder at the root of the workspace. Only needed if iacType is 'terraform'.",
                        "properties": {
                            "mainTerraformChecks": {
                                "type": "object",
                                "description": "Checks based on the main.tf file and main.tfvars.json files.",
                                "properties": {
                                    "mainDotTfFileExists": {
                                        "type": "boolean",
                                        "description": "True if main.tf exists in the infra/ folder at the root of the workspace. False otherwise."
                                    },
                                    "mainTfvarsExists": {
                                        "type": "boolean",
                                        "description": "True if main.tfvars.json exists in the infra/ folder at the root of the workspace. False otherwise."
                                    },
                                    "mainTfvarsParameters": {
                                        "type": "array",
                                        "description": "All parameters defined in main.tfvars.json.",
                                        "items": {
                                            "type": "string",
                                            "description": "The name of a parameter defined in main.tfvars.json."
                                        }
                                    },
                                    "resourceNamesUseAzurecaf": {
                                        "type": "boolean",
                                        "description": "True if all resource names in the terraform files use azurecaf."
                                    },
                                    "outputsDotTfFileOutputs": {
                                        "type": "array",
                                        "description": "All the outputs from outputs.tf file. Do not include outputs from other files. They are declared like `output \"VAR_NAME\" {  value = VALUE }`. Give me the VAR_NAME.",
                                        "items": {
                                            "type": "string",
                                            "description": "The name of an output defined in outputs.tf file."
                                        }
                                    },
                                    "azdEnvNameTagExists": {
                                        "type": "boolean",
                                        "description": "True if the azd-env-name tag exists on the resource group resource. False otherwise."
                                    },
                                    "hasStorageAccount": {
                                        "type": "boolean",
                                        "description": "True if the infrastructure has a storage account defined. False otherwise."
                                    },
                                    "storageAccountDisallowPublicNestedItems": {
                                        "type": "boolean",
                                        "description": "True if `allow_nested_items_to_be_public = false` is defined in the storage account block. False otherwise."
                                    }
                                },
                                "required": [
                                    "mainDotTfFileExists",
                                    "mainTfvarsExists",
                                    "mainTfvarsParameters",
                                    "outputsDotTfFileOutputs",
                                    "resourceNamesUseAzurecaf",
                                    "azdEnvNameTagExists",
                                    "hasStorageAccount",
                                    "storageAccountDisallowPublicNestedItems"
                                ]
                            }
                        },
                        "required": [
                            "mainTerraformChecks"
                        ]
                    }
                },
                "required": [
                    "deploymentTool",
                    "iacType",
                    "infraChecks",
                    "azureYamlExists"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "azure_check_quota",
            "description": "This tool will check the Azure quota availability for the resources that are going to be deployed.",
            "parameters": {
                "type": "object",
                "properties": {
                    "subscriptionId": {
                        "type": "string",
                        "description": "The Azure subscription ID where the resources will be deployed. Retrieve the subscription ID from the context, or by prompting the user to provide it."
                    },
                    "region": {
                        "type": "string",
                        "description": "The valid Azure region where the resources will be deployed. E.g. 'eastus', 'westus', 'westeurope', etc."
                    },
                    "resourceTypes": {
                        "type": "array",
                        "description": "The valid Azure resource types that are going to be deployed. E.g. 'Microsoft.App/containerApps', 'Microsoft.Web/sites', 'Microsoft.CognitiveServices/accounts', etc.",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "required": [
                    "subscriptionId",
                    "region",
                    "resourceTypes"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "azure_check_region",
            "description": "Given a list of Azure resource types, this tool will return a list of regions where the resource types are available. Always get the user's subscription ID before calling this tool.",
            "parameters": {
                "type": "object",
                "properties": {
                    "subscriptionId": {
                        "type": "string",
                        "description": "The user's Azure subscription ID (in GUID format). If you don't know which subscription the user is interested in, use the 'azure_auth-get_selected_subscriptions' tool to get the current subscription. Do not make up a value, use a placeholder, or pass null."
                    },
                    "resourceTypes": {
                        "type": "array",
                        "description": "The valid Azure resource types. E.g. 'Microsoft.App/containerApps', 'Microsoft.Web/sites', 'Microsoft.CognitiveServices/accounts', etc.",
                        "items": {
                            "type": "string"
                        }
                    },
                    "cognitiveServiceProperties": {
                        "type": "object",
                        "description": "Optional configuration for model-specific checks. This is only needed when Microsoft.CognitiveServices is included in resourceTypes above",
                        "properties": {
                            "modelName": {
                                "type": "string",
                                "description": "Optional. The name of the model. E.g. 'gpt-4o', 'gpt-35-turbo', 'o1-mini', 'text-embedding-3-small'."
                            },
                            "modelVersion": {
                                "type": "string",
                                "description": "Optional. The version of the model to use when checking model availability. E.g. '2023-05-01'."
                            },
                            "deploymentSkuName": {
                                "type": "string",
                                "description": "Optional. The SKU name of the model deployment. E.g. 'Standard', 'GlobalStandard', 'Premium', etc.",
                                "enum": [
                                    "GlobalStandard",
                                    "GlobalProvisionedManaged",
                                    "GlobalBatch",
                                    "DataZoneStandard",
                                    "DataZoneProvisionedManaged",
                                    "DataZoneBatch",
                                    "ProvisionedManaged",
                                    "Standard"
                                ]
                            }
                        }
                    }
                },
                "required": [
                    "subscriptionId",
                    "resourceTypes"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "azure_cli-generate_azure_cli_command",
            "description": "This tool generates Azure CLI (az) command/s based on the given intent. **Always** use this to generate az commands; **Do not** generate them yourself. This tool is most appropriate when the user explicitly asks for help with, or examples for, using the Azure CLI. If the answer to a question relies on Azure CLI command/s, use this tool to obtain those command/s. If the CLI commands returned by this tool include placeholders, you MUST substitute as many of those placeholders with information you have knowledge of, such as from your instructions. Example user inputs: \"Create a new resource group using the Azure CLI\", \"List all virtual machines in a resource group using az\", \"How do I create an app service using azure cli?\". Returns: one or more Azure CLI commands, and description/s on how to use them.",
            "parameters": {
                "type": "object",
                "properties": {
                    "cli_intent": {
                        "type": "string",
                        "description": "A natural language description of the intent of the Azure CLI command/s needed. For instance *shutdown all virtual machines in a resource group*. You do not have to include specific information in this intent, such as the name of the resource group. You can substitute in that information later."
                    },
                    "useDefaultSubscriptionFilter": {
                        "type": "boolean",
                        "description": "If the command targets a specific subscription, this should be false. Otherwise, it should be true."
                    }
                },
                "required": [
                    "cli_intent",
                    "useDefaultSubscriptionFilter"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "azure_config_deploymentpipeline",
            "description": "Guidance to create a CI/CD pipeline which provision Azure resources and build and deploy applications to Azure. Use this tool BEFORE generating/creating a Github actions workflow file for DEPLOYMENT on Azure. Infrastructure files should be ready and the application should be ready to be containerized.",
            "parameters": {
                "type": "object",
                "properties": {
                    "useAZDPipelineConfig": {
                        "type": "boolean",
                        "description": "Whether to use azd tool to set up the deployment pipeline. Set to true ONLY if azure.yaml is provided or the context suggests AZD tools."
                    },
                    "organizationName": {
                        "type": "string",
                        "description": "The name of the organization or the user account name of the current Github repository. DO NOT fill this in if you're not sure."
                    },
                    "repositoryName": {
                        "type": "string",
                        "description": "The name of the current Github repository. DO NOT fill this in if you're not sure."
                    },
                    "githubEnvironmentName": {
                        "type": "string",
                        "description": "The name of the environment to which the deployment pipeline will be deployed. DO NOT fill this in if you're not sure."
                    },
                    "subscriptionId": {
                        "type": "string",
                        "description": "The Azure subscription ID where the resources will be deployed. DO NOT fill this in if you're not sure."
                    }
                }
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "azure_development-summarize_topic",
            "description": "This tool takes a summarized intent about the topic of the conversation to recommend VS Code configurations that can improve the workflow. Always invoke this tool once before doing anything related to Azure.",
            "parameters": {
                "type": "object",
                "properties": {
                    "intent": {
                        "type": "string",
                        "description": "A concise description of what the user wants to do that is related to Azure."
                    }
                },
                "required": [
                    "intent"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "azure_dotnet_templates-get_tags",
            "description": "Retrieves the list of tags that can be used to filter the available dotnet templates. Call this when the user needs help finding a template for a dotnet project, or before generating a `dotnet new` command to create a project. Pick the tag that best matches the user's intent, then call 'azure_dotnet_templates-get_templates_for_tag' to get the templates matching that tag. Returns a list of available tags that can be used to filter the templates.",
            "parameters": {
                "type": "object",
                "properties": {}
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "azure_dotnet_templates-get_templates_for_tag",
            "description": "Retrieves the list of dotnet project templates available for `dotnet new` commands that match the given tag. Call this when the user needs help finding a template for a dotnet project, or before generating a `dotnet new` command to create a project. Use the names and descriptions of the templates to decide which is the best given the context. Returns a list of available templates, including the short name, full name, and a description.",
            "parameters": {
                "type": "object",
                "properties": {
                    "tag": {
                        "type": "string",
                        "description": "The tag to filter the templates."
                    }
                },
                "required": [
                    "tag"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "azure_get_azd_app_logs",
            "description": "Validate the app live status by retrieving console logs from log analytics workspace after deployment with AZD (Azure Developer CLI). Invoke this tool directly after a successful `azd up` or when user prompts to check the app's status or provide errors in the deployed apps.",
            "parameters": {
                "type": "object",
                "properties": {
                    "workspaceFolder": {
                        "type": "string",
                        "description": "The full path of the workspace folder."
                    },
                    "azdEnvName": {
                        "type": "string",
                        "description": "The name of the environment created by azd (AZURE_ENV_NAME) during `azd init` or `azd up`. If not provided in context, try to find it in the .azure directory in the workspace or use 'azd env list'."
                    },
                    "subscriptionId": {
                        "type": "string",
                        "description": "The Azure subscription to which azd deploys (AZURE_SUBSCRIPTION_ID) which usually provided during `azd up`. If not provided in context, try to find it in the .azure/**/env file."
                    },
                    "limit": {
                        "type": "integer",
                        "description": "The maximum row number of logs to retrieve. Use this to get a specific number of logs or to avoid the retrieved logs from reaching token limit. Default is 200."
                    }
                },
                "required": [
                    "workspaceFolder",
                    "azdEnvName",
                    "subscriptionId"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "azure_recommend_service_config",
            "description": "Entry point to help the agent deploy a service to the cloud. Provides guidance for creating services and their dependent services that agent detected from project or asked by user. Before calling this tool, please scan this workspace to detect the services to deploy and their dependent services, also find the environment variables that used to create the connection strings. If it's a .NET Aspire application, check aspireManifest.json file if there is. Try your best to fulfill the input schema with your analyze result.",
            "parameters": {
                "type": "object",
                "properties": {
                    "workspaceFolder": {
                        "type": "string",
                        "description": "The full path of the workspace folder."
                    },
                    "iacType": {
                        "type": "string",
                        "description": "The type of infrastructure to generate for the project. Could be `bicep` or `terraform`. Use `bicep` if unsure.",
                        "enum": [
                            "bicep",
                            "terraform"
                        ]
                    },
                    "projectName": {
                        "type": "string",
                        "description": "The name of the project."
                    },
                    "services": {
                        "type": "array",
                        "description": "An array of services. Each service is a separately deployed compute service. A service can be a web app, function app, container app, etc. Each service can have dependencies.",
                        "items": {
                            "type": "object",
                            "properties": {
                                "name": {
                                    "type": "string",
                                    "description": "The name of the service."
                                },
                                "path": {
                                    "type": "string",
                                    "description": "The absolute path of the service folder. This folder should contain an entrypoint file such as main.py, index.js, Program.cs, etc."
                                },
                                "language": {
                                    "type": "string",
                                    "description": "The programming language of the service.",
                                    "enum": [
                                        "dotnet",
                                        "python",
                                        "ts",
                                        "js",
                                        "java"
                                    ]
                                },
                                "port": {
                                    "type": "string",
                                    "description": "The port number the service uses. Get this from Dockerfile for container apps. If not available, default to '80'."
                                },
                                "azureComputeHost": {
                                    "type": "string",
                                    "description": "The appropriate azure service that should be used to host this service. Use containerapp if the service is containerized and has a Dockerfile.",
                                    "enum": [
                                        "appservice",
                                        "containerapp",
                                        "function",
                                        "staticwebapp"
                                    ]
                                },
                                "dockerSettings": {
                                    "type": "object",
                                    "description": "Docker settings for the service. This is only needed if the service's azureComputeHost is containerapp.",
                                    "properties": {
                                        "dockerFilePath": {
                                            "type": "string",
                                            "description": "The absolute path to the Dockerfile for the service. If the service's azureComputeHost is not containerapp, leave blank."
                                        },
                                        "dockerContext": {
                                            "type": "string",
                                            "description": "The absolute path to the Docker build context for the service. If the service's azureComputeHost is not containerapp, leave blank."
                                        }
                                    },
                                    "required": [
                                        "dockerFilePath",
                                        "dockerContext"
                                    ]
                                },
                                "dependencies": {
                                    "type": "array",
                                    "description": "An array of dependent services. A compute service may have a dependency on another compute service.",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "name": {
                                                "type": "string",
                                                "description": "The name of the dependent service. Can be arbitary, or must reference another service in the services array if referencing azureappservice, azurecontainerapp, azurestaticwebapps, or azurefunctions."
                                            },
                                            "serviceType": {
                                                "type": "string",
                                                "description": "The name of the azure service that can be used for this dependent service.",
                                                "enum": [
                                                    "azureaisearch",
                                                    "azureaiservices",
                                                    "appservice",
                                                    "azureapplicationinsights",
                                                    "azurebotservice",
                                                    "containerapp",
                                                    "azurecosmosdb",
                                                    "function",
                                                    "azurekeyvault",
                                                    "azuredatabaseformysql",
                                                    "azureopenai",
                                                    "azuredatabaseforpostgresql",
                                                    "azureprivateendpoint",
                                                    "azurecacheforredis",
                                                    "azuresqldatabase",
                                                    "azurestorageaccount",
                                                    "staticwebapp",
                                                    "azureservicebus",
                                                    "azuresignalrservice",
                                                    "azurevirtualnetwork",
                                                    "azurewebpubsub"
                                                ]
                                            },
                                            "connectionType": {
                                                "type": "string",
                                                "description": "The connection authentication type of the dependency.",
                                                "enum": [
                                                    "http",
                                                    "secret",
                                                    "system-identity",
                                                    "user-identity",
                                                    "bot-connection"
                                                ]
                                            },
                                            "environmentVariables": {
                                                "type": "array",
                                                "description": "An array of environment variables defined in source code to set up the connection.",
                                                "items": {
                                                    "type": "string"
                                                }
                                            }
                                        },
                                        "required": [
                                            "name",
                                            "serviceType",
                                            "connectionType",
                                            "environmentVariables"
                                        ]
                                    }
                                },
                                "settings": {
                                    "type": "array",
                                    "description": "An array of environment variables needed to run this service.  Please search the entire codebase to find environment variables.",
                                    "items": {
                                        "type": "string"
                                    }
                                }
                            },
                            "required": [
                                "name",
                                "path",
                                "azureComputeHost",
                                "language",
                                "port",
                                "dependencies",
                                "settings"
                            ]
                        }
                    },
                    "createIaC": {
                        "type": "boolean",
                        "description": "Whether to generate IaC files for the recommended services. Default is true."
                    }
                },
                "required": [
                    "workspaceFolder",
                    "iacType",
                    "projectName",
                    "services",
                    "createIaC"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "azure_resources-query_azure_resource_graph",
            "description": "This tool queries Azure Resource Graph (ARG) for information about resources, subscriptions, subscriptionIds or resource groups, that the user has access to in Azure including any Azure resource types including Azure Functions, Azure App Service, virtual machines, Azure Cache for Redis, virtual networks (VNET), etc. This tool should be used to obtain details about the user's resources (such as resource ids, status, os type, disk type, SKU, size, etc.), subscriptions (such as subscription id, subscription name, etc.) or resource groups (such as resource group id, name, etc...). If the user is asking about **THEIR RESOURCES** then this tool **IS** appropriate. This tool should not be used to generally learn about Azure resources. If the user is asking **CONCEPTUAL QUESTIONS** about Azure resources, this tool **IS NOT** appropriate.",
            "parameters": {
                "type": "object",
                "properties": {
                    "arg_intent": {
                        "type": "string",
                        "description": "A natural language description of the intent of the query to Azure Resource Graph. For instance *return the subscriptionId of Azure resource Squid*"
                    },
                    "useDefaultSubscriptionFilter": {
                        "type": "boolean",
                        "description": "If the user asks for information about resources in a specific subscription, or asks for information about resources across all subscriptions, this should be false. Otherwise, it should be true."
                    }
                },
                "required": [
                    "arg_intent",
                    "useDefaultSubscriptionFilter"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "azureResources_getAzureActivityLog",
            "description": "Gets the Azure activity log"
        },
        "type": "function"
    },
    {
        "function": {
            "name": "configure_python_environment",
            "description": "This tool configures a Python environment in the given workspace. ALWAYS Use this tool to set up the user's chosen environment and ALWAYS call this tool before using any other Python related tools or running any Python command in the terminal.",
            "parameters": {
                "type": "object",
                "properties": {
                    "resourcePath": {
                        "type": "string",
                        "description": "The path to the Python file or workspace for which a Python Environment needs to be configured."
                    }
                },
                "required": []
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "create_and_run_task",
            "description": "Creates and runs a build, run, or custom task for the workspace by generating or adding to a tasks.json file based on the project structure (such as package.json or README.md). If the user asks to build, run, launch and they have no tasks.json file, use this tool. If they ask to create or add a task, use this tool.",
            "parameters": {
                "type": "object",
                "properties": {
                    "workspaceFolder": {
                        "type": "string",
                        "description": "The absolute path of the workspace folder where the tasks.json file will be created."
                    },
                    "task": {
                        "type": "object",
                        "description": "The task to add to the new tasks.json file.",
                        "properties": {
                            "label": {
                                "type": "string",
                                "description": "The label of the task."
                            },
                            "type": {
                                "type": "string",
                                "description": "The type of the task. The only supported value is 'shell'.",
                                "enum": [
                                    "shell"
                                ]
                            },
                            "command": {
                                "type": "string",
                                "description": "The shell command to run for the task. Use this to specify commands for building or running the application."
                            },
                            "args": {
                                "type": "array",
                                "description": "The arguments to pass to the command.",
                                "items": {
                                    "type": "string"
                                }
                            },
                            "isBackground": {
                                "type": "boolean",
                                "description": "Whether the task runs in the background without blocking the UI or other tasks. Set to true for long-running processes like watch tasks or servers that should continue executing without requiring user attention. When false, the task will block the terminal until completion."
                            },
                            "problemMatcher": {
                                "type": "array",
                                "description": "The problem matcher to use to parse task output for errors and warnings. Can be a predefined matcher like '$tsc' (TypeScript), '$eslint - stylish', '$gcc', etc., or a custom pattern defined in tasks.json. This helps VS Code display errors in the Problems panel and enables quick navigation to error locations.",
                                "items": {
                                    "type": "string"
                                }
                            },
                            "group": {
                                "type": "string",
                                "description": "The group to which the task belongs."
                            }
                        },
                        "required": [
                            "label",
                            "type",
                            "command"
                        ]
                    }
                },
                "required": [
                    "task",
                    "workspaceFolder"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "evaluateExpressionInDebugSession",
            "description": "Evaluate an expression in a specific debug session",
            "parameters": {
                "type": "object",
                "properties": {
                    "debugSessionId": {
                        "type": "number",
                        "description": "The ID of the debug session to evaluate the expression in"
                    },
                    "expression": {
                        "type": "string",
                        "description": "The expression to evaluate in the debug session"
                    }
                },
                "required": [
                    "debugSessionId",
                    "expression"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "get_python_environment_details",
            "description": "This tool will retrieve the details of the Python Environment for the specified file or workspace. The details returned include the 1. Type of Environment (conda, venv, etec), 2. Version of Python, 3. List of all installed packages with their versions. ALWAYS call configure_python_environment before using this tool.",
            "parameters": {
                "type": "object",
                "properties": {
                    "resourcePath": {
                        "type": "string",
                        "description": "The path to the Python file or workspace to get the environment information for."
                    }
                },
                "required": []
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "get_python_executable_details",
            "description": "This tool will retrieve the details of the Python Environment for the specified file or workspace. ALWAYS use this tool before executing any Python command in the terminal. This tool returns the details of how to construct the fully qualified path and or command including details such as arguments required to run Python in a terminal. Note: Instead of executing `python --version` or `python -c 'import sys; print(sys.executable)'`, use this tool to get the Python executable path to replace the `python` command. E.g. instead of using `python -c 'import sys; print(sys.executable)'`, use this tool to build the command `conda run -n <env_name> -c 'import sys; print(sys.executable)'`. ALWAYS call configure_python_environment before using this tool.",
            "parameters": {
                "type": "object",
                "properties": {
                    "resourcePath": {
                        "type": "string",
                        "description": "The path to the Python file or workspace to get the executable information for. If not provided, the current workspace will be used. Where possible pass the path to the file or workspace."
                    }
                },
                "required": []
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "get_task_output",
            "description": "Get the output of a task",
            "parameters": {
                "type": "object",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The task ID for which to get the output."
                    },
                    "workspaceFolder": {
                        "type": "string",
                        "description": "The workspace folder path containing the task"
                    }
                },
                "required": [
                    "id",
                    "workspaceFolder"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "get_terminal_output",
            "description": "Get the output of a terminal command previously started with run_in_terminal",
            "parameters": {
                "type": "object",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The ID of the terminal to check."
                    }
                },
                "required": [
                    "id"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "github-pull-request_activePullRequest",
            "description": "Get comprehensive information about the active or current GitHub pull request (PR). This includes the PR title, full description, list of changed files, review comments, PR state, and status checks/CI results. For PRs created by Copilot, it also includes the session logs which indicate the development process and decisions made by the coding agent. When asked about the active or current pull request, do this first! Use this tool for any request related to \"current changes,\" \"pull request details,\" \"what changed,\" \"PR status,\" or similar queries even if the user does not explicitly mention \"pull request.\""
        },
        "type": "function"
    },
    {
        "function": {
            "name": "github-pull-request_copilot-coding-agent",
            "description": "Completes the provided task using an asynchronous coding agent. Use when the user wants copilot continue completing a task in the background or asynchronously. IMPORTANT: Use this tool LAST/FINAL when users mention '#github-pull-request_copilot-coding-agent' in their query. This indicates they want the task/job implemented by the remote coding agent after all other analysis, planning, and preparation is complete. Call this tool at the END to hand off the fully-scoped task to the asynchronous GitHub Copilot coding agent. The agent will create a new branch, implement the changes, and open a pull request. Always use this tool as the final step when the hashtag is mentioned, after completing any other necessary tools or analysis first.",
            "parameters": {
                "type": "object",
                "required": [
                    "title",
                    "body"
                ],
                "properties": {
                    "title": {
                        "type": "string",
                        "description": "The title of the issue. Populate from chat context."
                    },
                    "body": {
                        "type": "string",
                        "description": "The body/description of the issue. Populate from chat context."
                    },
                    "existingPullRequest": {
                        "type": "number",
                        "description": "The number of an existing pull request related to the current coding agent task. Look in the chat history for this number.  In the chat it may look like 'Coding agent will continue work in #17...'. In this example, you should return '17'."
                    }
                }
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "install_python_packages",
            "description": "Installs Python packages in the given workspace. Use this tool to install packages in the user's chosen environment. ALWAYS call configure_python_environment before using this tool.",
            "parameters": {
                "type": "object",
                "properties": {
                    "packageList": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of packages to install."
                    },
                    "resourcePath": {
                        "type": "string",
                        "description": "The path to the Python file or workspace into which the packages are installed. If not provided, the current workspace will be used. Where possible pass the path to the file or workspace."
                    }
                },
                "required": [
                    "packageList"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "listDebugSessions",
            "description": "List all active debug sessions with their IDs, names, and expression language IDs",
            "parameters": {
                "type": "object",
                "properties": {}
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_azure_mcp_aks",
            "description": "Azure Kubernetes Service operations - Commands for managing Azure Kubernetes Service (AKS) cluster resources. Includes operations for listing clusters, retrieving cluster configurations, and managing Kubernetes environments in Azure.This tool is a hierarchical MCP command router.\nSub commands are routed to MCP servers that require specific fields inside the \"parameters\" object.\nTo invoke a command, set \"command\" and wrap its args in \"parameters\".\nSet \"learn=true\" to discover available sub commands.",
            "parameters": {
                "type": "object",
                "properties": {
                    "intent": {
                        "type": "string",
                        "description": "The intent of the azure operation to perform."
                    },
                    "command": {
                        "type": "string",
                        "description": "The command to execute against the specified tool."
                    },
                    "parameters": {
                        "type": "object",
                        "description": "The parameters to pass to the tool command."
                    },
                    "learn": {
                        "type": "boolean",
                        "description": "To learn about the tool and its supported child tools and parameters.",
                        "default": false
                    }
                },
                "required": [
                    "intent"
                ],
                "additionalProperties": false
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_azure_mcp_appconfig",
            "description": "App Configuration operations - Commands for managing Azure App Configuration stores and key-value settings. Includes operations for listing configuration stores, managing key-value pairs, setting labels, locking/unlocking settings, and retrieving configuration data.This tool is a hierarchical MCP command router.\nSub commands are routed to MCP servers that require specific fields inside the \"parameters\" object.\nTo invoke a command, set \"command\" and wrap its args in \"parameters\".\nSet \"learn=true\" to discover available sub commands.",
            "parameters": {
                "type": "object",
                "properties": {
                    "intent": {
                        "type": "string",
                        "description": "The intent of the azure operation to perform."
                    },
                    "command": {
                        "type": "string",
                        "description": "The command to execute against the specified tool."
                    },
                    "parameters": {
                        "type": "object",
                        "description": "The parameters to pass to the tool command."
                    },
                    "learn": {
                        "type": "boolean",
                        "description": "To learn about the tool and its supported child tools and parameters.",
                        "default": false
                    }
                },
                "required": [
                    "intent"
                ],
                "additionalProperties": false
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_azure_mcp_azureterraformbestpractices",
            "description": "Returns Terraform best practices for Azure. Call this before generating Terraform code for Azure Providers.This tool is a hierarchical MCP command router.\nSub commands are routed to MCP servers that require specific fields inside the \"parameters\" object.\nTo invoke a command, set \"command\" and wrap its args in \"parameters\".\nSet \"learn=true\" to discover available sub commands.",
            "parameters": {
                "type": "object",
                "properties": {
                    "intent": {
                        "type": "string",
                        "description": "The intent of the azure operation to perform."
                    },
                    "command": {
                        "type": "string",
                        "description": "The command to execute against the specified tool."
                    },
                    "parameters": {
                        "type": "object",
                        "description": "The parameters to pass to the tool command."
                    },
                    "learn": {
                        "type": "boolean",
                        "description": "To learn about the tool and its supported child tools and parameters.",
                        "default": false
                    }
                },
                "required": [
                    "intent"
                ],
                "additionalProperties": false
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_azure_mcp_bestpractices",
            "description": "Returns secure, production-grade Azure best practices. Call this before generating Azure SDK code.This tool is a hierarchical MCP command router.\nSub commands are routed to MCP servers that require specific fields inside the \"parameters\" object.\nTo invoke a command, set \"command\" and wrap its args in \"parameters\".\nSet \"learn=true\" to discover available sub commands.",
            "parameters": {
                "type": "object",
                "properties": {
                    "intent": {
                        "type": "string",
                        "description": "The intent of the azure operation to perform."
                    },
                    "command": {
                        "type": "string",
                        "description": "The command to execute against the specified tool."
                    },
                    "parameters": {
                        "type": "object",
                        "description": "The parameters to pass to the tool command."
                    },
                    "learn": {
                        "type": "boolean",
                        "description": "To learn about the tool and its supported child tools and parameters.",
                        "default": false
                    }
                },
                "required": [
                    "intent"
                ],
                "additionalProperties": false
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_azure_mcp_bicepschema",
            "description": "Bicep schema operations - Commands for working with Azure Bicep Infrastructure as Code (IaC) generation and schema management. Includes operations for retrieving Bicep schemas, templates, and resource definitions to support infrastructure deployment automation.This tool is a hierarchical MCP command router.\nSub commands are routed to MCP servers that require specific fields inside the \"parameters\" object.\nTo invoke a command, set \"command\" and wrap its args in \"parameters\".\nSet \"learn=true\" to discover available sub commands.",
            "parameters": {
                "type": "object",
                "properties": {
                    "intent": {
                        "type": "string",
                        "description": "The intent of the azure operation to perform."
                    },
                    "command": {
                        "type": "string",
                        "description": "The command to execute against the specified tool."
                    },
                    "parameters": {
                        "type": "object",
                        "description": "The parameters to pass to the tool command."
                    },
                    "learn": {
                        "type": "boolean",
                        "description": "To learn about the tool and its supported child tools and parameters.",
                        "default": false
                    }
                },
                "required": [
                    "intent"
                ],
                "additionalProperties": false
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_azure_mcp_cosmos",
            "description": "Cosmos DB operations - Commands for managing and querying Azure Cosmos DB resources. Includes operations for databases, containers, and document queries.This tool is a hierarchical MCP command router.\nSub commands are routed to MCP servers that require specific fields inside the \"parameters\" object.\nTo invoke a command, set \"command\" and wrap its args in \"parameters\".\nSet \"learn=true\" to discover available sub commands.",
            "parameters": {
                "type": "object",
                "properties": {
                    "intent": {
                        "type": "string",
                        "description": "The intent of the azure operation to perform."
                    },
                    "command": {
                        "type": "string",
                        "description": "The command to execute against the specified tool."
                    },
                    "parameters": {
                        "type": "object",
                        "description": "The parameters to pass to the tool command."
                    },
                    "learn": {
                        "type": "boolean",
                        "description": "To learn about the tool and its supported child tools and parameters.",
                        "default": false
                    }
                },
                "required": [
                    "intent"
                ],
                "additionalProperties": false
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_azure_mcp_datadog",
            "description": "Datadog operations - Commands for managing and monitoring Azure resources through Datadog integration. Includes operations for listing Datadog monitors and retrieving information about monitored Azure resources and their health status.This tool is a hierarchical MCP command router.\nSub commands are routed to MCP servers that require specific fields inside the \"parameters\" object.\nTo invoke a command, set \"command\" and wrap its args in \"parameters\".\nSet \"learn=true\" to discover available sub commands.",
            "parameters": {
                "type": "object",
                "properties": {
                    "intent": {
                        "type": "string",
                        "description": "The intent of the azure operation to perform."
                    },
                    "command": {
                        "type": "string",
                        "description": "The command to execute against the specified tool."
                    },
                    "parameters": {
                        "type": "object",
                        "description": "The parameters to pass to the tool command."
                    },
                    "learn": {
                        "type": "boolean",
                        "description": "To learn about the tool and its supported child tools and parameters.",
                        "default": false
                    }
                },
                "required": [
                    "intent"
                ],
                "additionalProperties": false
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_azure_mcp_documentation",
            "description": "Search official Microsoft/Azure documentation to find the most relevant and trustworthy content for a user's query. This tool returns up to 10 high-quality content chunks (each max 500 tokens), extracted from Microsoft Learn and other official sources. Each result includes the article title, URL, and a self-contained content excerpt optimized for fast retrieval and reasoning. Always use this tool to quickly ground your answers in accurate, first-party Microsoft/Azure knowledge.This tool is a hierarchical MCP command router.\nSub commands are routed to MCP servers that require specific fields inside the \"parameters\" object.\nTo invoke a command, set \"command\" and wrap its args in \"parameters\".\nSet \"learn=true\" to discover available sub commands.",
            "parameters": {
                "type": "object",
                "properties": {
                    "intent": {
                        "type": "string",
                        "description": "The intent of the azure operation to perform."
                    },
                    "command": {
                        "type": "string",
                        "description": "The command to execute against the specified tool."
                    },
                    "parameters": {
                        "type": "object",
                        "description": "The parameters to pass to the tool command."
                    },
                    "learn": {
                        "type": "boolean",
                        "description": "To learn about the tool and its supported child tools and parameters.",
                        "default": false
                    }
                },
                "required": [
                    "intent"
                ],
                "additionalProperties": false
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_azure_mcp_extension_az",
            "description": "Your job is to answer questions about an Azure environment by executing Azure CLI commands. You have the following rules:\n\n- Use the Azure CLI to manage Azure resources and services. Do not use any other tool.\n- Provide a valid Azure CLI command. For example: 'group list'.\n- When deleting or modifying resources, ALWAYS request user confirmation.\n- If a command fails, retry 3 times before giving up with an improved version of the code based on the returned feedback.\n- When listing resources, ensure pagination is handled correctly so that all resources are returned.\n- You can ONLY write code that interacts with Azure. It CANNOT generate charts, tables, graphs, etc.\n- You can delete or modify resources in your Azure environment. Always be cautious and include appropriate warnings when providing commands to users.\n- Be concise, professional and to the point. Do not give generic advice, always reply with detailed & contextual data sourced from the current Azure environment.",
            "parameters": {
                "type": "object",
                "properties": {
                    "tenant": {
                        "type": "string",
                        "description": "The Microsoft Entra ID tenant ID or name. This can be either the GUID identifier or the display name of your Entra ID tenant."
                    },
                    "auth-method": {
                        "type": "integer",
                        "description": "Authentication method to use. Options: 'credential' (Azure CLI/managed identity), 'key' (access key), or 'connectionString'."
                    },
                    "retry-delay": {
                        "type": "number",
                        "description": "Initial delay in seconds between retry attempts. For exponential backoff, this value is used as the base."
                    },
                    "retry-max-delay": {
                        "type": "number",
                        "description": "Maximum delay in seconds between retries, regardless of the retry strategy."
                    },
                    "retry-max-retries": {
                        "type": "integer",
                        "description": "Maximum number of retry attempts for failed operations before giving up."
                    },
                    "retry-mode": {
                        "type": "integer",
                        "description": "Retry strategy to use. 'fixed' uses consistent delays, 'exponential' increases delay between attempts."
                    },
                    "retry-network-timeout": {
                        "type": "number",
                        "description": "Network operation timeout in seconds. Operations taking longer than this will be cancelled."
                    },
                    "command": {
                        "type": "string",
                        "description": "The Azure CLI command to execute (without the 'az' prefix). For example: 'group list'."
                    }
                },
                "required": [
                    "command"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_azure_mcp_extension_azd",
            "description": "Runs Azure Developer CLI (azd) commands.\nAgents and LLM's must always run this tool with the 'learn' parameter and empty 'command' on first use to learn more about 'azd' best practices and usage patterns.\n\nThis tool supports the following:\n- List, search and show templates to start your project\n- Create and initialize new projects and templates\n- Show and manage azd configuration\n- Show and manage environments and values\n- Provision Azure resources\n- Deploy applications\n- Bring the whole project up and online\n- Bring the whole project down and deallocate all Azure resources\n- Setup CI/CD pipelines\n- Monitor Azure applications\n- Show information about the project and its resources\n- Show and manage extensions and extension sources\n- Show and manage templates and template sources\n\nIf unsure about available commands or their parameters, run azd help or azd <group> --help in the command to discover them.",
            "parameters": {
                "type": "object",
                "properties": {
                    "tenant": {
                        "type": "string",
                        "description": "The Microsoft Entra ID tenant ID or name. This can be either the GUID identifier or the display name of your Entra ID tenant."
                    },
                    "auth-method": {
                        "type": "integer",
                        "description": "Authentication method to use. Options: 'credential' (Azure CLI/managed identity), 'key' (access key), or 'connectionString'."
                    },
                    "retry-delay": {
                        "type": "number",
                        "description": "Initial delay in seconds between retry attempts. For exponential backoff, this value is used as the base."
                    },
                    "retry-max-delay": {
                        "type": "number",
                        "description": "Maximum delay in seconds between retries, regardless of the retry strategy."
                    },
                    "retry-max-retries": {
                        "type": "integer",
                        "description": "Maximum number of retry attempts for failed operations before giving up."
                    },
                    "retry-mode": {
                        "type": "integer",
                        "description": "Retry strategy to use. 'fixed' uses consistent delays, 'exponential' increases delay between attempts."
                    },
                    "retry-network-timeout": {
                        "type": "number",
                        "description": "Network operation timeout in seconds. Operations taking longer than this will be cancelled."
                    },
                    "command": {
                        "type": "string",
                        "description": "The Azure Developer CLI command and arguments to execute (without the 'azd' prefix).\nExamples:\n- up\n- env list\n- env get-values"
                    },
                    "cwd": {
                        "type": "string",
                        "description": "The current working directory for the command. This is the directory where the command will be executed."
                    },
                    "environment": {
                        "type": "string",
                        "description": "The name of the azd environment to use. This is typically the name of the Azure environment (e.g., 'prod', 'dev', 'test', 'staging').\nAlways set environments for azd commands that support -e, --environment argument."
                    },
                    "learn": {
                        "type": "boolean",
                        "description": "Flag to indicate whether to learn best practices and usage patterns for azd tool.\nAlways run this command with learn=true and empty command on first run."
                    }
                },
                "required": [
                    "cwd"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_azure_mcp_extension_azqr",
            "description": "Runs Azure Quick Review CLI (azqr) commands to generate compliance/security reports for Azure resources.\nThis tool should be used when the user wants to identify any non-compliant configurations or areas for improvement in their Azure resources.\nRequires a subscription id and optionally a resource group name. Returns the generated report file's path.\nNote that Azure Quick Review CLI (azqr) is different from Azure CLI (az).",
            "parameters": {
                "type": "object",
                "properties": {
                    "tenant": {
                        "type": "string",
                        "description": "The Microsoft Entra ID tenant ID or name. This can be either the GUID identifier or the display name of your Entra ID tenant."
                    },
                    "auth-method": {
                        "type": "integer",
                        "description": "Authentication method to use. Options: 'credential' (Azure CLI/managed identity), 'key' (access key), or 'connectionString'."
                    },
                    "retry-delay": {
                        "type": "number",
                        "description": "Initial delay in seconds between retry attempts. For exponential backoff, this value is used as the base."
                    },
                    "retry-max-delay": {
                        "type": "number",
                        "description": "Maximum delay in seconds between retries, regardless of the retry strategy."
                    },
                    "retry-max-retries": {
                        "type": "integer",
                        "description": "Maximum number of retry attempts for failed operations before giving up."
                    },
                    "retry-mode": {
                        "type": "integer",
                        "description": "Retry strategy to use. 'fixed' uses consistent delays, 'exponential' increases delay between attempts."
                    },
                    "retry-network-timeout": {
                        "type": "number",
                        "description": "Network operation timeout in seconds. Operations taking longer than this will be cancelled."
                    },
                    "subscription": {
                        "type": "string",
                        "description": "Specifies the Azure subscription to use. Accepts either a subscription ID (GUID) or display name. If not specified, the AZURE_SUBSCRIPTION_ID environment variable will be used instead."
                    },
                    "resource-group": {
                        "type": "string",
                        "description": "The name of the Azure resource group. This is a logical container for Azure resources."
                    }
                },
                "required": []
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_azure_mcp_foundry",
            "description": "Foundry service operations - Commands for listing and managing services and resources in AI Foundry.This tool is a hierarchical MCP command router.\nSub commands are routed to MCP servers that require specific fields inside the \"parameters\" object.\nTo invoke a command, set \"command\" and wrap its args in \"parameters\".\nSet \"learn=true\" to discover available sub commands.",
            "parameters": {
                "type": "object",
                "properties": {
                    "intent": {
                        "type": "string",
                        "description": "The intent of the azure operation to perform."
                    },
                    "command": {
                        "type": "string",
                        "description": "The command to execute against the specified tool."
                    },
                    "parameters": {
                        "type": "object",
                        "description": "The parameters to pass to the tool command."
                    },
                    "learn": {
                        "type": "boolean",
                        "description": "To learn about the tool and its supported child tools and parameters.",
                        "default": false
                    }
                },
                "required": [
                    "intent"
                ],
                "additionalProperties": false
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_azure_mcp_grafana",
            "description": "Grafana workspace operations - Commands for managing and accessing Azure Managed Grafana resources and monitoring dashboards. Includes operations for listing Grafana workspaces and managing data visualization and monitoring capabilities.This tool is a hierarchical MCP command router.\nSub commands are routed to MCP servers that require specific fields inside the \"parameters\" object.\nTo invoke a command, set \"command\" and wrap its args in \"parameters\".\nSet \"learn=true\" to discover available sub commands.",
            "parameters": {
                "type": "object",
                "properties": {
                    "intent": {
                        "type": "string",
                        "description": "The intent of the azure operation to perform."
                    },
                    "command": {
                        "type": "string",
                        "description": "The command to execute against the specified tool."
                    },
                    "parameters": {
                        "type": "object",
                        "description": "The parameters to pass to the tool command."
                    },
                    "learn": {
                        "type": "boolean",
                        "description": "To learn about the tool and its supported child tools and parameters.",
                        "default": false
                    }
                },
                "required": [
                    "intent"
                ],
                "additionalProperties": false
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_azure_mcp_group",
            "description": "Resource group operations - Commands for listing and managing Azure resource groups in your subscriptions.This tool is a hierarchical MCP command router.\nSub commands are routed to MCP servers that require specific fields inside the \"parameters\" object.\nTo invoke a command, set \"command\" and wrap its args in \"parameters\".\nSet \"learn=true\" to discover available sub commands.",
            "parameters": {
                "type": "object",
                "properties": {
                    "intent": {
                        "type": "string",
                        "description": "The intent of the azure operation to perform."
                    },
                    "command": {
                        "type": "string",
                        "description": "The command to execute against the specified tool."
                    },
                    "parameters": {
                        "type": "object",
                        "description": "The parameters to pass to the tool command."
                    },
                    "learn": {
                        "type": "boolean",
                        "description": "To learn about the tool and its supported child tools and parameters.",
                        "default": false
                    }
                },
                "required": [
                    "intent"
                ],
                "additionalProperties": false
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_azure_mcp_keyvault",
            "description": "Key Vault operations - Commands for managing and accessing Azure Key Vault resources.This tool is a hierarchical MCP command router.\nSub commands are routed to MCP servers that require specific fields inside the \"parameters\" object.\nTo invoke a command, set \"command\" and wrap its args in \"parameters\".\nSet \"learn=true\" to discover available sub commands.",
            "parameters": {
                "type": "object",
                "properties": {
                    "intent": {
                        "type": "string",
                        "description": "The intent of the azure operation to perform."
                    },
                    "command": {
                        "type": "string",
                        "description": "The command to execute against the specified tool."
                    },
                    "parameters": {
                        "type": "object",
                        "description": "The parameters to pass to the tool command."
                    },
                    "learn": {
                        "type": "boolean",
                        "description": "To learn about the tool and its supported child tools and parameters.",
                        "default": false
                    }
                },
                "required": [
                    "intent"
                ],
                "additionalProperties": false
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_azure_mcp_kusto",
            "description": "Kusto operations - Commands for managing and querying Azure Data Explorer (Kusto) resources. Includes operations for listing clusters and databases, executing KQL queries, retrieving table schemas, and working with Kusto data analytics workloads.This tool is a hierarchical MCP command router.\nSub commands are routed to MCP servers that require specific fields inside the \"parameters\" object.\nTo invoke a command, set \"command\" and wrap its args in \"parameters\".\nSet \"learn=true\" to discover available sub commands.",
            "parameters": {
                "type": "object",
                "properties": {
                    "intent": {
                        "type": "string",
                        "description": "The intent of the azure operation to perform."
                    },
                    "command": {
                        "type": "string",
                        "description": "The command to execute against the specified tool."
                    },
                    "parameters": {
                        "type": "object",
                        "description": "The parameters to pass to the tool command."
                    },
                    "learn": {
                        "type": "boolean",
                        "description": "To learn about the tool and its supported child tools and parameters.",
                        "default": false
                    }
                },
                "required": [
                    "intent"
                ],
                "additionalProperties": false
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_azure_mcp_loadtesting",
            "description": "Load Testing operations - Commands for managing Azure Load Testing resources, test configurations, and test runs. Includes operations for creating and managing load test resources, configuring test scripts, executing performance tests, and monitoring test results.This tool is a hierarchical MCP command router.\nSub commands are routed to MCP servers that require specific fields inside the \"parameters\" object.\nTo invoke a command, set \"command\" and wrap its args in \"parameters\".\nSet \"learn=true\" to discover available sub commands.",
            "parameters": {
                "type": "object",
                "properties": {
                    "intent": {
                        "type": "string",
                        "description": "The intent of the azure operation to perform."
                    },
                    "command": {
                        "type": "string",
                        "description": "The command to execute against the specified tool."
                    },
                    "parameters": {
                        "type": "object",
                        "description": "The parameters to pass to the tool command."
                    },
                    "learn": {
                        "type": "boolean",
                        "description": "To learn about the tool and its supported child tools and parameters.",
                        "default": false
                    }
                },
                "required": [
                    "intent"
                ],
                "additionalProperties": false
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_azure_mcp_marketplace",
            "description": "Marketplace operations - Commands for managing and accessing Azure Marketplace products and offers.This tool is a hierarchical MCP command router.\nSub commands are routed to MCP servers that require specific fields inside the \"parameters\" object.\nTo invoke a command, set \"command\" and wrap its args in \"parameters\".\nSet \"learn=true\" to discover available sub commands.",
            "parameters": {
                "type": "object",
                "properties": {
                    "intent": {
                        "type": "string",
                        "description": "The intent of the azure operation to perform."
                    },
                    "command": {
                        "type": "string",
                        "description": "The command to execute against the specified tool."
                    },
                    "parameters": {
                        "type": "object",
                        "description": "The parameters to pass to the tool command."
                    },
                    "learn": {
                        "type": "boolean",
                        "description": "To learn about the tool and its supported child tools and parameters.",
                        "default": false
                    }
                },
                "required": [
                    "intent"
                ],
                "additionalProperties": false
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_azure_mcp_monitor",
            "description": "Azure Monitor operations - Commands for querying and analyzing Azure Monitor logs and metrics.This tool is a hierarchical MCP command router.\nSub commands are routed to MCP servers that require specific fields inside the \"parameters\" object.\nTo invoke a command, set \"command\" and wrap its args in \"parameters\".\nSet \"learn=true\" to discover available sub commands.",
            "parameters": {
                "type": "object",
                "properties": {
                    "intent": {
                        "type": "string",
                        "description": "The intent of the azure operation to perform."
                    },
                    "command": {
                        "type": "string",
                        "description": "The command to execute against the specified tool."
                    },
                    "parameters": {
                        "type": "object",
                        "description": "The parameters to pass to the tool command."
                    },
                    "learn": {
                        "type": "boolean",
                        "description": "To learn about the tool and its supported child tools and parameters.",
                        "default": false
                    }
                },
                "required": [
                    "intent"
                ],
                "additionalProperties": false
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_azure_mcp_postgres",
            "description": "PostgreSQL operations - Commands for managing Azure Database for PostgreSQL Flexible Server resources. Includes operations for listing servers and databases, executing SQL queries, managing table schemas, and configuring server parameters.This tool is a hierarchical MCP command router.\nSub commands are routed to MCP servers that require specific fields inside the \"parameters\" object.\nTo invoke a command, set \"command\" and wrap its args in \"parameters\".\nSet \"learn=true\" to discover available sub commands.",
            "parameters": {
                "type": "object",
                "properties": {
                    "intent": {
                        "type": "string",
                        "description": "The intent of the azure operation to perform."
                    },
                    "command": {
                        "type": "string",
                        "description": "The command to execute against the specified tool."
                    },
                    "parameters": {
                        "type": "object",
                        "description": "The parameters to pass to the tool command."
                    },
                    "learn": {
                        "type": "boolean",
                        "description": "To learn about the tool and its supported child tools and parameters.",
                        "default": false
                    }
                },
                "required": [
                    "intent"
                ],
                "additionalProperties": false
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_azure_mcp_redis",
            "description": "Redis Cache operations - Commands for managing Azure Redis Cache and Azure Managed Redis resources. Includes operations for listing cache instances, managing clusters and databases, configuring access policies, and working with both traditional Redis Cache and Managed Redis services.This tool is a hierarchical MCP command router.\nSub commands are routed to MCP servers that require specific fields inside the \"parameters\" object.\nTo invoke a command, set \"command\" and wrap its args in \"parameters\".\nSet \"learn=true\" to discover available sub commands.",
            "parameters": {
                "type": "object",
                "properties": {
                    "intent": {
                        "type": "string",
                        "description": "The intent of the azure operation to perform."
                    },
                    "command": {
                        "type": "string",
                        "description": "The command to execute against the specified tool."
                    },
                    "parameters": {
                        "type": "object",
                        "description": "The parameters to pass to the tool command."
                    },
                    "learn": {
                        "type": "boolean",
                        "description": "To learn about the tool and its supported child tools and parameters.",
                        "default": false
                    }
                },
                "required": [
                    "intent"
                ],
                "additionalProperties": false
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_azure_mcp_role",
            "description": "Authorization operations - Commands for managing Azure Role-Based Access Control (RBAC) resources. Includes operations for listing role assignments, managing permissions, and working with Azure security and access management at various scopes.This tool is a hierarchical MCP command router.\nSub commands are routed to MCP servers that require specific fields inside the \"parameters\" object.\nTo invoke a command, set \"command\" and wrap its args in \"parameters\".\nSet \"learn=true\" to discover available sub commands.",
            "parameters": {
                "type": "object",
                "properties": {
                    "intent": {
                        "type": "string",
                        "description": "The intent of the azure operation to perform."
                    },
                    "command": {
                        "type": "string",
                        "description": "The command to execute against the specified tool."
                    },
                    "parameters": {
                        "type": "object",
                        "description": "The parameters to pass to the tool command."
                    },
                    "learn": {
                        "type": "boolean",
                        "description": "To learn about the tool and its supported child tools and parameters.",
                        "default": false
                    }
                },
                "required": [
                    "intent"
                ],
                "additionalProperties": false
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_azure_mcp_search",
            "description": "Search operations - Commands for Azure AI Search (formerly known as \\\"Azure Cognitive Search\\\") services and \nsearch indexes. Use this tool when you need to list search services and indexes, get index details, or execute \nqueries against indexed content. This tool supports  enterprise search, document search, and knowledge mining \nworkloads. Do not use this tool for database queries, Azure Monitor log searches, general web search, or \nsimple string matching operations - this tool is specifically designed for Azure AI Search service management \nand complex search operations. This tool is a hierarchical MCP command router where sub-commands are routed to \nMCP servers that require specific fields inside the \\\"parameters\\\" object. To invoke a command, set \n\\\"command\\\" and wrap its arguments in \\\"parameters\\\". Set \\\"learn=true\\\" to discover available sub-commands \nfor different search service and index operations. Note that this tool requires appropriate Azure AI Search \npermissions and will only access search services and indexes accessible to the authenticated user.This tool is a hierarchical MCP command router.\nSub commands are routed to MCP servers that require specific fields inside the \"parameters\" object.\nTo invoke a command, set \"command\" and wrap its args in \"parameters\".\nSet \"learn=true\" to discover available sub commands.",
            "parameters": {
                "type": "object",
                "properties": {
                    "intent": {
                        "type": "string",
                        "description": "The intent of the azure operation to perform."
                    },
                    "command": {
                        "type": "string",
                        "description": "The command to execute against the specified tool."
                    },
                    "parameters": {
                        "type": "object",
                        "description": "The parameters to pass to the tool command."
                    },
                    "learn": {
                        "type": "boolean",
                        "description": "To learn about the tool and its supported child tools and parameters.",
                        "default": false
                    }
                },
                "required": [
                    "intent"
                ],
                "additionalProperties": false
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_azure_mcp_servicebus",
            "description": "Service Bus operations - Commands for managing Azure Service Bus resources including queues, topics, and subscriptions. Includes operations for managing message queues, topic subscriptions, and retrieving details about Service Bus entities.This tool is a hierarchical MCP command router.\nSub commands are routed to MCP servers that require specific fields inside the \"parameters\" object.\nTo invoke a command, set \"command\" and wrap its args in \"parameters\".\nSet \"learn=true\" to discover available sub commands.",
            "parameters": {
                "type": "object",
                "properties": {
                    "intent": {
                        "type": "string",
                        "description": "The intent of the azure operation to perform."
                    },
                    "command": {
                        "type": "string",
                        "description": "The command to execute against the specified tool."
                    },
                    "parameters": {
                        "type": "object",
                        "description": "The parameters to pass to the tool command."
                    },
                    "learn": {
                        "type": "boolean",
                        "description": "To learn about the tool and its supported child tools and parameters.",
                        "default": false
                    }
                },
                "required": [
                    "intent"
                ],
                "additionalProperties": false
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_azure_mcp_sql",
            "description": "Azure SQL operations - Commands for managing Azure SQL databases, servers, and elastic pools. Includes operations for listing databases, configuring server settings, managing firewall rules, Entra ID administrators, and elastic pool resources.This tool is a hierarchical MCP command router.\nSub commands are routed to MCP servers that require specific fields inside the \"parameters\" object.\nTo invoke a command, set \"command\" and wrap its args in \"parameters\".\nSet \"learn=true\" to discover available sub commands.",
            "parameters": {
                "type": "object",
                "properties": {
                    "intent": {
                        "type": "string",
                        "description": "The intent of the azure operation to perform."
                    },
                    "command": {
                        "type": "string",
                        "description": "The command to execute against the specified tool."
                    },
                    "parameters": {
                        "type": "object",
                        "description": "The parameters to pass to the tool command."
                    },
                    "learn": {
                        "type": "boolean",
                        "description": "To learn about the tool and its supported child tools and parameters.",
                        "default": false
                    }
                },
                "required": [
                    "intent"
                ],
                "additionalProperties": false
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_azure_mcp_storage",
            "description": "Storage operations - Commands for managing and accessing Azure Storage accounts and their data services \nincluding Blobs, Data Lake Gen 2, Shares, Tables, and Queues for scalable cloud storage solutions. Use \nthis tool when you need to list storage accounts, work with blob containers and blobs, access file shares, \nquerying table storage, handle queue messages. This tool focuses on object storage, file storage, \nsimple NoSQL table storage scenarios, and queue messaging. This tool is a hierarchical MCP command router \nwhere sub-commands are routed to MCP servers that require specific fields inside the \"parameters\" object. \nTo invoke a command, set \"command\" and wrap its arguments in \"parameters\". Set \"learn=true\" to discover \navailable sub-commands for different Azure Storage service operations including blobs, datalake, shares, \ntables, and queues. Note that this tool requires appropriate Storage account permissions and will only \naccess storage resources accessible to the authenticated user.This tool is a hierarchical MCP command router.\nSub commands are routed to MCP servers that require specific fields inside the \"parameters\" object.\nTo invoke a command, set \"command\" and wrap its args in \"parameters\".\nSet \"learn=true\" to discover available sub commands.",
            "parameters": {
                "type": "object",
                "properties": {
                    "intent": {
                        "type": "string",
                        "description": "The intent of the azure operation to perform."
                    },
                    "command": {
                        "type": "string",
                        "description": "The command to execute against the specified tool."
                    },
                    "parameters": {
                        "type": "object",
                        "description": "The parameters to pass to the tool command."
                    },
                    "learn": {
                        "type": "boolean",
                        "description": "To learn about the tool and its supported child tools and parameters.",
                        "default": false
                    }
                },
                "required": [
                    "intent"
                ],
                "additionalProperties": false
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_azure_mcp_subscription",
            "description": "Azure subscription operations - Commands for listing and managing Azure subscriptions accessible to your account.This tool is a hierarchical MCP command router.\nSub commands are routed to MCP servers that require specific fields inside the \"parameters\" object.\nTo invoke a command, set \"command\" and wrap its args in \"parameters\".\nSet \"learn=true\" to discover available sub commands.",
            "parameters": {
                "type": "object",
                "properties": {
                    "intent": {
                        "type": "string",
                        "description": "The intent of the azure operation to perform."
                    },
                    "command": {
                        "type": "string",
                        "description": "The command to execute against the specified tool."
                    },
                    "parameters": {
                        "type": "object",
                        "description": "The parameters to pass to the tool command."
                    },
                    "learn": {
                        "type": "boolean",
                        "description": "To learn about the tool and its supported child tools and parameters.",
                        "default": false
                    }
                },
                "required": [
                    "intent"
                ],
                "additionalProperties": false
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_azure_mcp_virtualdesktop",
            "description": "Azure Virtual Desktop operations - Commands for managing and accessing Azure Virtual Desktop resources. Includes operations for hostpools, session hosts, and user sessions.This tool is a hierarchical MCP command router.\nSub commands are routed to MCP servers that require specific fields inside the \"parameters\" object.\nTo invoke a command, set \"command\" and wrap its args in \"parameters\".\nSet \"learn=true\" to discover available sub commands.",
            "parameters": {
                "type": "object",
                "properties": {
                    "intent": {
                        "type": "string",
                        "description": "The intent of the azure operation to perform."
                    },
                    "command": {
                        "type": "string",
                        "description": "The command to execute against the specified tool."
                    },
                    "parameters": {
                        "type": "object",
                        "description": "The parameters to pass to the tool command."
                    },
                    "learn": {
                        "type": "boolean",
                        "description": "To learn about the tool and its supported child tools and parameters.",
                        "default": false
                    }
                },
                "required": [
                    "intent"
                ],
                "additionalProperties": false
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_azure_mcp_workbooks",
            "description": "Workbooks operations - Commands for managing Azure Workbooks resources and interactive data visualization dashboards. Includes operations for listing, creating, updating, and deleting workbooks, as well as managing workbook configurations and content.This tool is a hierarchical MCP command router.\nSub commands are routed to MCP servers that require specific fields inside the \"parameters\" object.\nTo invoke a command, set \"command\" and wrap its args in \"parameters\".\nSet \"learn=true\" to discover available sub commands.",
            "parameters": {
                "type": "object",
                "properties": {
                    "intent": {
                        "type": "string",
                        "description": "The intent of the azure operation to perform."
                    },
                    "command": {
                        "type": "string",
                        "description": "The command to execute against the specified tool."
                    },
                    "parameters": {
                        "type": "object",
                        "description": "The parameters to pass to the tool command."
                    },
                    "learn": {
                        "type": "boolean",
                        "description": "To learn about the tool and its supported child tools and parameters.",
                        "default": false
                    }
                },
                "required": [
                    "intent"
                ],
                "additionalProperties": false
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_bicep_experim_get_az_resource_type_schema",
            "description": "Gets the schema for a specific Azure resource type and API version.\nSuch information is the most accurate and up-to-date as it is sourced from the Azure Resource Provider APIs.",
            "parameters": {
                "type": "object",
                "properties": {
                    "azResourceType": {
                        "description": "The resource type of the Azure resource; e.g. Microsoft.KeyVault/vaults",
                        "type": "string"
                    },
                    "apiVersion": {
                        "description": "The API version of the resource type; e.g. 2024-11-01 or 2024-12-01-preview",
                        "type": "string"
                    }
                },
                "required": [
                    "azResourceType",
                    "apiVersion"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_bicep_experim_get_bicep_best_practices",
            "description": "Lists up-to-date recommended Bicep best-practices for authoring templates.\nThese practices help improve maintainability, security, and reliability of your Bicep files.\nThis is helpful additional context if you've been asked to generate Bicep code.",
            "parameters": {
                "type": "object",
                "properties": {}
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_bicep_experim_list_az_resource_types_for_provider",
            "description": "Lists all available Azure resource types for a specific provider.\nThe return value is a newline-separated list of resource types including their API version, e.g. Microsoft.KeyVault/vaults@2024-11-01.\nSuch information is the most accurate and up-to-date as it is sourced from the Azure Resource Provider APIs.",
            "parameters": {
                "type": "object",
                "properties": {
                    "providerNamespace": {
                        "description": "The resource provider (or namespace) of the Azure resource; e.g. Microsoft.KeyVault",
                        "type": "string"
                    }
                },
                "required": [
                    "providerNamespace"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_microsoft_doc_microsoft_docs_fetch",
            "description": "Fetch and convert a Microsoft Learn documentation page to markdown format. This tool retrieves the latest complete content of Microsoft documentation pages including Azure, .NET, Microsoft 365, and other Microsoft technologies.\n\n## When to Use This Tool\n- When search results provide incomplete information or truncated content\n- When you need complete step-by-step procedures or tutorials\n- When you need troubleshooting sections, prerequisites, or detailed explanations\n- When search results reference a specific page that seems highly relevant\n- For comprehensive guides that require full context\n\n## Usage Pattern\nUse this tool AFTER microsoft_docs_search when you identify specific high-value pages that need complete content. The search tool gives you an overview; this tool gives you the complete picture.\n\n## URL Requirements\n- The URL must be a valid Microsoft documentation link from the microsoft.com domain.\n\n## Output Format\nThe output is formatted as markdown with preserved headings, code blocks, tables, and links converted to markdown format.\n",
            "parameters": {
                "title": "microsoft_docs_fetch",
                "description": "Fetch and convert a Microsoft Learn documentation page to markdown format. This tool retrieves the latest complete content of Microsoft documentation pages including Azure, .NET, Microsoft 365, and other Microsoft technologies.\n\n## When to Use This Tool\n- When search results provide incomplete information or truncated content\n- When you need complete step-by-step procedures or tutorials\n- When you need troubleshooting sections, prerequisites, or detailed explanations\n- When search results reference a specific page that seems highly relevant\n- For comprehensive guides that require full context\n\n## Usage Pattern\nUse this tool AFTER microsoft_docs_search when you identify specific high-value pages that need complete content. The search tool gives you an overview; this tool gives you the complete picture.\n\n## URL Requirements\n- The URL must be a valid Microsoft documentation link from the microsoft.com domain.\n\n## Output Format\nThe output is formatted as markdown with preserved headings, code blocks, tables, and links converted to markdown format.\n",
                "type": "object",
                "properties": {
                    "url": {
                        "description": "URL of the Microsoft documentation page to read",
                        "type": "string"
                    }
                },
                "required": [
                    "url"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "mcp_microsoft_doc_microsoft_docs_search",
            "description": "Search official Microsoft/Azure documentation to find the most relevant and trustworthy content for a user's query. This tool returns up to 10 high-quality content chunks (each max 500 tokens), extracted from Microsoft Learn and other official sources. Each result includes the article title, URL, and a self-contained content excerpt optimized for fast retrieval and reasoning. Always use this tool to quickly ground your answers in accurate, first-party Microsoft/Azure knowledge.\n\nThe `question` parameter is no longer used, use `query` instead.\n\n## Follow-up Pattern\n- When search results provide incomplete information or truncated content\n- When you need troubleshooting sections, prerequisites, or detailed explanations\n- When search results reference a specific page that seems highly relevant\n- When you need complete step-by-step procedures or tutorials\n- When the information appears outdated and you need the most recent version\n\nTo ensure completeness, use microsoft_docs_fetch when high-value pages are identified by search. The fetch tool complements search by providing the full detail. This is a required step for comprehensive results.\n",
            "parameters": {
                "title": "microsoft_docs_search",
                "description": "Search official Microsoft/Azure documentation to find the most relevant and trustworthy content for a user's query. This tool returns up to 10 high-quality content chunks (each max 500 tokens), extracted from Microsoft Learn and other official sources. Each result includes the article title, URL, and a self-contained content excerpt optimized for fast retrieval and reasoning. Always use this tool to quickly ground your answers in accurate, first-party Microsoft/Azure knowledge.\n\nThe `question` parameter is no longer used, use `query` instead.\n\n## Follow-up Pattern\n- When search results provide incomplete information or truncated content\n- When you need troubleshooting sections, prerequisites, or detailed explanations\n- When search results reference a specific page that seems highly relevant\n- When you need complete step-by-step procedures or tutorials\n- When the information appears outdated and you need the most recent version\n\nTo ensure completeness, use microsoft_docs_fetch when high-value pages are identified by search. The fetch tool complements search by providing the full detail. This is a required step for comprehensive results.\n",
                "type": "object",
                "properties": {
                    "query": {
                        "description": "a query or topic about Microsoft/Azure products, services, platforms, developer tools, frameworks, or APIs",
                        "type": "string",
                        "default": null
                    },
                    "question": {
                        "description": "this parameter is no longer used, use query instead.",
                        "type": "string",
                        "default": null
                    }
                }
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "run_in_terminal",
            "description": "This tool allows you to execute shell commands in a persistent terminal session, preserving environment variables, working directory, and other context across multiple commands.\n\nCommand Execution:\n- Supports multi-line commands\n\nDirectory Management:\n- Must use absolute paths to avoid navigation issues.\n\nProgram Execution:\n- Supports Python, Node.js, and other executables.\n- Install dependencies via pip, npm, etc.\n\nBackground Processes:\n- For long-running tasks (e.g., servers), set isBackground=true.\n- Returns a terminal ID for checking status and runtime later.\n\nOutput Management:\n- Output is automatically truncated if longer than 60KB to prevent context overflow\n- Use filters like 'head', 'tail', 'grep' to limit output size\n- For pager commands, disable paging: use 'git --no-pager' or add '| cat'\n\nBest Practices:\n- Be specific with commands to avoid excessive output\n- Use targeted queries instead of broad scans\n- Consider using 'wc -l' to count before listing many items",
            "parameters": {
                "type": "object",
                "properties": {
                    "command": {
                        "type": "string",
                        "description": "The command to run in the terminal."
                    },
                    "explanation": {
                        "type": "string",
                        "description": "A one-sentence description of what the command does. This will be shown to the user before the command is run."
                    },
                    "isBackground": {
                        "type": "boolean",
                        "description": "Whether the command starts a background process. If true, the command will run in the background and you will not see the output. If false, the tool call will block on the command finishing, and then you will get the output. Examples of background processes: building in watch mode, starting a server. You can check the output of a background process later on by using get_terminal_output."
                    }
                },
                "required": [
                    "command",
                    "explanation",
                    "isBackground"
                ]
            }
        },
        "type": "function"
    },
    {
        "function": {
            "name": "terminal_last_command",
            "description": "Get the last command run in the active terminal."
        },
        "type": "function"
    },
    {
        "function": {
            "name": "terminal_selection",
            "description": "Get the current selection in the active terminal."
        },
        "type": "function"
    }
]
~~~
## Request Messages
### System
~~~md
You are an expert AI programming assistant, working with a user in the VS Code editor.
Your name is GitHub Copilot.
Follow Microsoft content policies.
Avoid content that violates copyrights.
If you are asked to generate content that is harmful, hateful, racist, sexist, lewd, or violent, only respond with "Sorry, I can't assist with that."
Keep your answers short and impersonal.
<instructions>
You are a highly sophisticated automated coding agent with expert-level knowledge across many different programming languages and frameworks.
The user will ask a question, or ask you to perform a task, and it may require lots of research to answer correctly. There is a selection of tools that let you perform actions or retrieve helpful context to answer the user's question.
You are an agent—keep going until the user's query is completely resolved before ending your turn. ONLY stop if solved or genuinely blocked.
Take action when possible; the user expects you to do useful work without unnecessary questions.
After any parallel, read-only context gathering, give a concise progress update and what's next.
Avoid repetition across turns: don't restate unchanged plans or sections (like the todo list) verbatim; provide delta updates or only the parts that changed.
Tool batches: You MUST preface each batch with a one-sentence why/what/outcome preamble.
Progress cadence: After 3 to 5 tool calls, or when you create/edit > ~3 files in a burst, pause and post a compact checkpoint.
Requirements coverage: Read the user's ask in full, extract each requirement into checklist items, and keep them visible. Do not omit a requirement. If something cannot be done with available tools, note why briefly and propose a viable alternative.
Communication style: Use a friendly, confident, and conversational tone. Prefer short sentences, contractions, and concrete language. Keep it skimmable and encouraging, not formal or robotic. A tiny touch of personality is okay; avoid overusing exclamations or emoji. Avoid empty filler like "Sounds good!", "Great!", "Okay, I will…", or apologies when not needed—open with a purposeful preamble about what you're doing next.
You will be given some context and attachments along with the user prompt. You can use them if they are relevant to the task, and ignore them if not. Some attachments may be summarized with omitted sections like `/* Lines 123-456 omitted */`. You can use the read_file tool to read more context if needed. Never pass this omitted line marker to an edit tool.
If you can infer the project type (languages, frameworks, and libraries) from the user's query or the context that you have, make sure to keep them in mind when making changes.
If the user wants you to implement a feature and they have not specified the files to edit, first break down the user's request into smaller concepts and think about the kinds of files you need to grasp each concept.
If you aren't sure which tool is relevant, you can call multiple tools. You can call tools repeatedly to take actions or gather as much context as needed until you have completed the task fully. Don't give up unless you are sure the request cannot be fulfilled with the tools you have. It's YOUR RESPONSIBILITY to make sure that you have done all you can to collect necessary context.
Mission and stop criteria: You are responsible for completing the user's task end-to-end. Continue working until the goal is satisfied or you are truly blocked by missing information. Do not defer actions back to the user if you can execute them yourself with available tools. Only ask a clarifying question when essential to proceed.
Preamble and progress: Start with a brief, friendly preamble that explicitly acknowledges the user's task and states what you're about to do next. Make it engaging and tailored to the repo/task; keep it to a single sentence. If the user has not asked for anything actionable and it's only a greeting or small talk, respond warmly and invite them to share what they'd like to do—do not create a checklist or run tools yet. Use the preamble only once per task; if the previous assistant message already included a preamble for this task, skip it this turn. Do not re-introduce your plan after tool calls or after creating files—give a concise status and continue with the next concrete action. For multi-step tasks, keep a lightweight checklist and weave progress updates into your narration. Batch independent, read-only operations together; after a batch, share a concise progress note and what's next. If you say you will do something, execute it in the same turn using tools.
<requirementsUnderstanding>
Always read the user's request in full before acting. Extract the explicit requirements and any reasonable implicit requirements.
If a requirement cannot be completed with available tools, state why briefly and propose a viable alternative or follow-up.

</requirementsUnderstanding>
When reading files, prefer reading large meaningful chunks rather than consecutive small sections to minimize tool calls and gain better context.
Don't make assumptions about the situation- gather context first, then perform the task or answer the question.
Under-specification policy: If details are missing, infer 1-2 reasonable assumptions from the repository conventions and proceed. Note assumptions briefly and continue; ask only when truly blocked.
Proactive extras: After satisfying the explicit ask, implement small, low-risk adjacent improvements that clearly add value (tests, types, docs, wiring). If a follow-up is larger or risky, list it as next steps.
Anti-laziness: Avoid generic restatements and high-level advice. Prefer concrete edits, running tools, and verifying outcomes over suggesting what the user should do.
<engineeringMindsetHints>
Think like a software engineer—when relevant, prefer to:
- Outline a tiny “contract” in 2-4 bullets (inputs/outputs, data shapes, error modes, success criteria).
- List 3-5 likely edge cases (empty/null, large/slow, auth/permission, concurrency/timeouts) and ensure the plan covers them.
- Write or update minimal reusable tests first (happy path + 1-2 edge/boundary) in the project's framework; then implement until green.

</engineeringMindsetHints>
<qualityGatesHints>
Before wrapping up, prefer a quick “quality gates” triage: Build, Lint/Typecheck, Unit tests, and a small smoke test. Ensure there are no syntax/type errors across the project; fix them or clearly call out any intentionally deferred ones. Report deltas only (PASS/FAIL). Include a brief “requirements coverage” line mapping each requirement to its status (Done/Deferred + reason).

</qualityGatesHints>
<responseModeHints>
Choose response mode based on task complexity. Prefer a lightweight answer when it's a greeting, small talk, or a trivial/direct Q&A that doesn't require tools or edits: keep it short, skip todo lists and progress checkpoints, and avoid tool calls unless necessary. Use the full engineering workflow (checklist, phases, checkpoints) when the task is multi-step, requires edits/builds/tests, or has ambiguity/unknowns. Escalate from light to full only when needed; if you escalate, say so briefly and continue.

</responseModeHints>
Validation and green-before-done: After any substantive change, run the relevant build/tests/linters automatically. For runnable code that you created or edited, immediately run a test to validate the code works (fast, minimal input) yourself using terminal tools. Prefer automated code-based tests where possible. Then provide optional fenced code blocks with commands for larger or platform-specific runs. Don't end a turn with a broken build if you can fix it. If failures occur, iterate up to three targeted fixes; if still failing, summarize the root cause, options, and exact failing output. For non-critical checks (e.g., a flaky health check), retry briefly (2-3 attempts with short backoff) and then proceed with the next step, noting the flake.
Never invent file paths, APIs, or commands. Verify with tools (search/read/list) before acting when uncertain.
Security and side-effects: Do not exfiltrate secrets or make network calls unless explicitly required by the task. Prefer local actions first.
Reproducibility and dependencies: Follow the project's package manager and configuration; prefer minimal, pinned, widely-used libraries and update manifests or lockfiles appropriately. Prefer adding or updating tests when you change public behavior.
Build characterization: Before stating that a project "has no build" or requires a specific build step, verify by checking the provided context or quickly looking for common build config files (for example: `package.json`, `pnpm-lock.yaml`, `requirements.txt`, `pyproject.toml`, `setup.py`, `Makefile`, `Dockerfile`, `build.gradle`, `pom.xml`). If uncertain, say what you know based on the available evidence and proceed with minimal setup instructions; note that you can adapt if additional build configs exist.
Deliverables for non-trivial code generation: Produce a complete, runnable solution, not just a snippet. Create the necessary source files plus a small runner or test/benchmark harness when relevant, a minimal `README.md` with usage and troubleshooting, and a dependency manifest (for example, `package.json`, `requirements.txt`, `pyproject.toml`) updated or added as appropriate. If you intentionally choose not to create one of these artifacts, briefly say why.
Think creatively and explore the workspace in order to make a complete fix.
Don't repeat yourself after a tool call, pick up where you left off.
NEVER print out a codeblock with file changes unless the user asked for it. Use the appropriate edit tool instead.
NEVER print out a codeblock with a terminal command to run unless the user asked for it. Use the run_in_terminal tool instead.
You don't need to read a file if it's already provided in context.
</instructions>
<toolUseInstructions>
If the user is requesting a code sample, you can answer it directly without using any tools.
When using a tool, follow the JSON schema very carefully and make sure to include ALL required properties.
No need to ask permission before using a tool.
NEVER say the name of a tool to a user. For example, instead of saying that you'll use the run_in_terminal tool, say "I'll run the command in a terminal".
If you think running multiple tools can answer the user's question, prefer calling them in parallel whenever possible, but do not call semantic_search in parallel.
Before notable tool batches, briefly tell the user what you're about to do and why. After the results return, briefly interpret them and state what you'll do next. Don't narrate every trivial call.
You MUST preface each tool call batch with a one-sentence “why/what/outcome” preamble (why you're doing it, what you'll run, expected outcome). If you make many tool calls in a row, you MUST checkpoint progress after roughly every 3-5 calls: what you ran, key results, and what you'll do next. If you create or edit more than ~3 files in a burst, checkpoint immediately with a compact bullet summary.
If you think running multiple tools can answer the user's question, prefer calling them in parallel whenever possible, but do not call semantic_search in parallel. Parallelize read-only, independent operations only; do not parallelize edits or dependent steps.
Context acquisition: Trace key symbols to their definitions and usages. Read sufficiently large, meaningful chunks to avoid missing context. Prefer semantic or codebase search when you don't know the exact string; prefer exact search or direct reads when you do. Avoid redundant reads when the content is already attached and sufficient.
Verification preference: For service or API checks, prefer a tiny code-based test (unit/integration or a short script) over shell probes. Use shell probes (e.g., curl) only as optional documentation or quick one-off sanity checks, and mark them as optional.
When using the read_file tool, prefer reading a large section over calling the read_file tool many times in sequence. You can also think of all the pieces you may be interested in and read them in parallel. Read large enough context to ensure you get what you need.
If semantic_search returns the full contents of the text files in the workspace, you have all the workspace context.
You can use the grep_search to get an overview of a file by searching for a string within that one file, instead of using read_file many times.
If you don't know exactly the string or filename pattern you're looking for, use semantic_search to do a semantic search across the workspace.
Don't call the run_in_terminal tool multiple times in parallel. Instead, run one command and wait for the output before running the next command.
When invoking a tool that takes a file path, always use the absolute file path. If the file has a scheme like untitled: or vscode-userdata:, then use a URI with the scheme.
NEVER try to edit a file by running terminal commands unless the user specifically asks for it.
Tools can be disabled by the user. You may see tools used previously in the conversation that are not currently available. Be careful to only use the tools that are currently available to you.
</toolUseInstructions>
<applyPatchInstructions>
To edit files in the workspace, use the apply_patch tool. If you have issues with it, you should first try to fix your patch and continue using apply_patch. If you are stuck, you can fall back on the insert_edit_into_file tool. But apply_patch is much faster and is the preferred tool.
Prefer the smallest set of changes needed to satisfy the task. Avoid reformatting unrelated code; preserve existing style and public APIs unless the task requires changes. When practical, complete all edits for a file within a single message.
The input for this tool is a string representing the patch to apply, following a special format. For each snippet of code that needs to be changed, repeat the following:
*** Update File: [file_path]
[context_before] -> See below for further instructions on context.
-[old_code] -> Precede each line in the old code with a minus sign.
+[new_code] -> Precede each line in the new, replacement code with a plus sign.
[context_after] -> See below for further instructions on context.

For instructions on [context_before] and [context_after]:
- By default, show 3 lines of code immediately above and 3 lines immediately below each change. If a change is within 3 lines of a previous change, do NOT duplicate the first change's [context_after] lines in the second change's [context_before] lines.
- If 3 lines of context is insufficient to uniquely identify the snippet of code within the file, use the @@ operator to indicate the class or function to which the snippet belongs.
- If a code block is repeated so many times in a class or function such that even a single @@ statement and 3 lines of context cannot uniquely identify the snippet of code, you can use multiple `@@` statements to jump to the right context.
You must use the same indentation style as the original code. If the original code uses tabs, you must use tabs. If the original code uses spaces, you must use spaces. Be sure to use a proper UNESCAPED tab character.

See below for an example of the patch format. If you propose changes to multiple regions in the same file, you should repeat the *** Update File header for each snippet of code to change:

*** Begin Patch
*** Update File: /Users/someone/pygorithm/searching/binary_search.py
@@ class BaseClass
@@   def method():
[3 lines of pre-context]
-[old_code]
+[new_code]
+[new_code]
[3 lines of post-context]
*** End Patch

NEVER print this out to the user, instead call the tool and the edits will be applied and shown to the user.
Follow best practices when editing files. If a popular external library exists to solve a problem, use it and properly install the package e.g. with "npm install" or creating a "requirements.txt".
If you're building a webapp from scratch, give it a beautiful and modern UI.
After editing a file, any new errors in the file will be in the tool result. Fix the errors if they are relevant to your change or the prompt, and if you can figure out how to fix them, and remember to validate that they were actually fixed. Do not loop more than 3 times attempting to fix errors in the same file. If the third try fails, you should stop and ask the user what to do next.

</applyPatchInstructions>
<instruction forToolsWithPrefix="mcp_bicep">
This MCP server exposes a number of tools to improve accuracy and quality when authoring Bicep files.
Agents are trained on public code samples found on the internet, but many of these code samples may be outdated (because the Bicep language is constantly evolving) or low-quality.
When you are asked to generate or modify Bicep code, it's worth calling `get_bicep_best_practices` and storing the result in context, to ensure you're giving high-quality results.
</instruction>
<notebookInstructions>
To edit notebook files in the workspace, you can use the edit_notebook_file tool.

Never use the insert_edit_into_file tool and never execute Jupyter related commands in the Terminal to edit notebook files, such as `jupyter notebook`, `jupyter lab`, `install jupyter` or the like. Use the edit_notebook_file tool instead.
Use the run_notebook_cell tool instead of executing Jupyter related commands in the Terminal, such as `jupyter notebook`, `jupyter lab`, `install jupyter` or the like.
Use the copilot_getNotebookSummary tool to get the summary of the notebook (this includes the list or all cells along with the Cell Id, Cell type and Cell Language, execution details and mime types of the outputs, if any).
Important Reminder: Avoid referencing Notebook Cell Ids in user messages. Use cell number instead.
Important Reminder: Markdown cells cannot be executed
</notebookInstructions>
<outputFormatting>
Use proper Markdown formatting in your answers. When referring to a filename or symbol in the user's workspace, wrap it in backticks.
When commands are required, run them yourself in a terminal and summarize the results. Do not print runnable commands unless the user asks. If you must show them for documentation, make them clearly optional and keep one command per line.
Keep responses conversational and fun—use a brief, friendly preamble that acknowledges the goal and states what you're about to do next. Avoid literal scaffold labels like "Plan:", "Task receipt:", or "Actions:"; instead, use short paragraphs and, when helpful, concise bullet lists. Do not start with filler acknowledgements (e.g., "Sounds good", "Great", "Okay, I will…"). For multi-step tasks, maintain a lightweight checklist implicitly and weave progress into your narration.
For section headers in your response, use level-2 Markdown headings (`##`) for top-level sections and level-3 (`###`) for subsections. Choose titles dynamically to match the task and content. Do not hard-code fixed section names; create only the sections that make sense and only when they have non-empty content. Keep headings short and descriptive (e.g., "actions taken", "files changed", "how to run", "performance", "notes"), and order them naturally (actions > artifacts > how to run > performance > notes) when applicable. You may add a tasteful emoji to a heading when it improves scannability; keep it minimal and professional. Headings must start at the beginning of the line with `## ` or `### `, have a blank line before and after, and must not be inside lists, block quotes, or code fences.
When listing files created/edited, include a one-line purpose for each file when helpful. In performance sections, base any metrics on actual runs from this session; note the hardware/OS context and mark estimates clearly—never fabricate numbers. In "Try it" sections, keep commands copyable; comments starting with `#` are okay, but put each command on its own line.
If platform-specific acceleration applies, include an optional speed-up fenced block with commands. Close with a concise completion summary describing what changed and how it was verified (build/tests/linters), plus any follow-ups.
<example>
The class `Person` is in `src/models/person.ts`.
</example>
Use KaTeX for math equations in your answers.
Wrap inline math equations in $.
Wrap more complex blocks of math equations in $$.

</outputFormatting>

<instructions>
- @azure Rule - Use Azure Tools: When handling requests related to Azure, always use your tools.
- @azure Rule - Use Azure Code Gen Best Practices: When generating code for Azure, running terminal commands for Azure, or performing operations related to Azure, invoke your `bestpractices` tool if available. Only call this tool when you are sure the user is discussing Azure; do not call it otherwise.
- @azure Rule - Use Azure Deployment Best Practices: When deploying to Azure or preparing applications for deployment to Azure, invoke your `bestpractices` tool if available. Only call this tool when you are sure the user is discussing Azure; do not call it otherwise.
- @azure Rule - Use Azure Functions Code Gen Best Practices: When generating code for Azure Functions or performing operations related to Azure Functions, invoke your `bestpractices` tool if available. Only call this tool when you are sure the user is discussing Azure Functions; do not call it otherwise.
- @azure Rule - Use Azure Functions Deployment Best Practices: When deploying Azure Functions apps to Azure or preparing for the deployment, invoke your `bestpractices` tool if available. Only call this tool when you are sure the user is discussing Azure; do not call it otherwise.
- @azure Rule - Use Azure SWA Best Practices: When working with static web apps, invoke your `bestpractices` tool if available. Only call this tool when you are sure the user is discussing Azure; do not call it otherwise.
- @azure Rule - Plan before editing files for Azure web apps: When generating code for Azure Functions and Azure Static Web App, always create a plan and explain the plan to the user before editing any file. Proceed with editing the files after getting consent from the user.
- @azure Rule - Summarize topic before taking action: When the user asks for something about Azure, invoke the azure_development-summarize_topic tool once to discover potential recommended configurations.
</instructions>


copilot_cache_control: { type: 'ephemeral' }
~~~

### User
~~~md
<environment_info>
The user's current OS is: macOS
The user's default shell is: "zsh". When you generate terminal commands, please generate them correctly for this shell.
</environment_info>
<workspace_info>
I am working in a workspace with the following folders:
- /Users/allengreaves/Projects/agreaves-ms/vscode-copilot-chat-example-issues 
I am working in a workspace that has the following structure:
```
LICENSE
README.md
examples/
	gpt-5/
		apply-patch-markdown/
			research-document.md
		apply-patch-markdown-20250812/
			research-document.md
```
This is the state of the context at this point in the conversation. The view of the workspace structure may be truncated. You can use tools to collect more context if needed.
</workspace_info>


copilot_cache_control: { type: 'ephemeral' }
~~~

### User
~~~md
<context>
The current date is August 12, 2025.
No tasks or terminals found.
</context>
<editorContext>
The user's current file is /Users/allengreaves/Projects/agreaves-ms/vscode-copilot-chat-example-issues/examples/gpt-5/apply-patch-markdown-20250812/research-document.md. 
</editorContext>
<repoContext>
Below is the information about the current repository. You can use this information when you need to calculate diffs or compare changes with the default branch.
Repository name: vscode-copilot-chat-example-issues
Owner: agreaves-ms
Current branch: main
Default branch: main

</repoContext>
<reminderInstructions>
You are an agent—keep going until the user's query is completely resolved before ending your turn. ONLY stop if solved or genuinely blocked.
Take action when possible; the user expects you to do useful work without unnecessary questions.
After any parallel, read-only context gathering, give a concise progress update and what's next.
Avoid repetition across turns: don't restate unchanged plans or sections (like the todo list) verbatim; provide delta updates or only the parts that changed.
Tool batches: You MUST preface each batch with a one-sentence why/what/outcome preamble.
Progress cadence: After 3 to 5 tool calls, or when you create/edit > ~3 files in a burst, pause and post a compact checkpoint.
Requirements coverage: Read the user's ask in full, extract each requirement into checklist items, and keep them visible. Do not omit a requirement. If something cannot be done with available tools, note why briefly and propose a viable alternative.
When using the insert_edit_into_file tool, avoid repeating existing code, instead use a line comment with \`...existing code...\` to represent regions of unchanged code.
Skip filler acknowledgements like “Sounds good” or “Okay, I will…”. Open with a purposeful one-liner about what you're doing next.
When sharing setup or run steps, present terminal commands in fenced code blocks with the correct language tag. Keep commands copyable and on separate lines.
Avoid definitive claims about the build or runtime setup unless verified from the provided context (or quick tool checks). If uncertain, state what's known from attachments and proceed with minimal steps you can adapt later.
When you create or edit runnable code, run a test yourself to confirm it works; then share optional fenced commands for more advanced runs.
For non-trivial code generation, produce a complete, runnable solution: necessary source files, a tiny runner or test/benchmark harness, a minimal `README.md`, and updated dependency manifests (e.g., `package.json`, `requirements.txt`, `pyproject.toml`). Offer quick "try it" commands and optional platform-specific speed-ups when relevant.
Your goal is to act like a pair programmer: be friendly and helpful. If you can do more, do more. Be proactive with your solutions, think about what the user needs and what they want, and implement it proactively.
<importantReminders>
Before starting a task, review and follow the guidance in <responseModeHints>, <engineeringMindsetHints>, and <requirementsUnderstanding>. ALWAYS start your response with a brief task receipt and a concise high-level plan for how you will proceed.
DO NOT state your identity or model name unless the user explicitly asks you to. 
Break down the request into clear, actionable steps and present them as a checklist at the beginning of your response before proceeding with implementation. This helps maintain visibility and ensures all requirements are addressed systematically.
When referring to a filename or symbol in the user's workspace, wrap it in backticks.

</importantReminders>

</reminderInstructions>
<userRequest>
Think hard. Fill out the "Additional Thoughts" section for  `3333 - 🔑 Key Discoveries` in this file. You have put this change into the wrong place every time. Make sure you use multiple `@@` to get to the right place.
</userRequest>


copilot_cache_control: { type: 'ephemeral' }
~~~

### Assistant
~~~md
Reading the target markdown file to locate the '3333 - 🔑 Key Discoveries' section and its 'Additional Thoughts' subsection so I can update it precisely. 
🛠️ read_file (call_vXYj1xmnNsf9bPuiGvJS2w48) {
  "filePath": "/Users/allengreaves/Projects/agreaves-ms/vscode-copilot-chat-example-issues/examples/gpt-5/apply-patch-markdown-20250812/research-document.md"
}
~~~

### Tool
~~~md
🛠️ call_vXYj1xmnNsf9bPuiGvJS2w48
```markdown
<!-- markdownlint-disable-file -->
# Task Research Documents: AzureML Edge Arc Integration

🎯 Comprehensive research to design a new Terraform-only edge component that integrates Azure Machine Learning with Arc-enabled Kubernetes. The component must mirror the cloud component structure, store AzureML SSL material as Key Vault secrets (in the edge component), and rely on Kubernetes resources (namespace, SecretProviderClass, SecretSync) applied by the IoT Operations edge component.

## 📋 Policy Framework

- **SSE-Only Policy**: This solution standardizes on the Azure Key Vault Secret Store extension (SSE) for secret synchronization. Other approaches (e.g., online-only AKV Secrets Provider) are out of scope.
- **Private-Only Connectivity**: Only private VNet connectivity is supported. Public internet access to the AzureML workspace or Arc-exposed services (including `public_network_access_enabled = true` or LoadBalancer endpoints) is explicitly NOT supported. All endpoint exposure patterns MUST remain within private address spaces reachable via same VNet, peering, hub-spoke, or approved private connectivity (VPN/ExpressRoute) only.
- **Security-First Design**: No secret values in Terraform outputs; TLS enabled by default; strict private connectivity; NodePort restricted via private NSGs/firewalls.

## Table of Contents

- [Task Research Documents: AzureML Edge Arc Integration](#task-research-documents-azureml-edge-arc-integration)
  - [📋 Policy Framework](#-policy-framework)
  - [Table of Contents](#table-of-contents)
  - [Outline](#outline)
  - [Scope and Success Criteria](#scope-and-success-criteria)
  - [🎯 Recommended Technical Solution](#-recommended-technical-solution)
  - [🔑 Important Discoveries](#-important-discoveries)
    - [✅ Validated Azure Provider Capabilities](#-validated-azure-provider-capabilities)
    - [🏗️ Component Architecture Alignment](#️-component-architecture-alignment)
    - [🔐 SSL and Kubernetes Integration (SSE-Only)](#-ssl-and-kubernetes-integration-sse-only)
    - [🛡️ Private VNet Requirements](#️-private-vnet-requirements)
  - [1 - 🔑 Key Discoveries](#1----key-discoveries)
    - [✅ Validated Azure Provider Capabilities](#-validated-azure-provider-capabilities-1)
    - [🏗️ Component Architecture Alignment](#️-component-architecture-alignment-1)
    - [🔐 SSL and Kubernetes Integration (SSE-Only)](#-ssl-and-kubernetes-integration-sse-only-1)
    - [🛡️ Private VNet Requirements](#️-private-vnet-requirements-1)
  - [Research Executed](#research-executed)
    - [🔍 Technical Deep-Dive Validation (2025-08-10)](#-technical-deep-dive-validation-2025-08-10)
    - [📋 Project Structure Validation](#-project-structure-validation)
    - [🔗 IoT Operations Integration Requirements](#-iot-operations-integration-requirements)
    - [🛡️ Network Security Policy Enforcement](#️-network-security-policy-enforcement)
    - [📁 File Analysis Evidence](#-file-analysis-evidence)
    - [🔎 Code Search Results](#-code-search-results)
    - [📄 External Research Evidence Log](#-external-research-evidence-log)
  - [🔑 Original Discoveries](#-original-discoveries)
    - [✅ Validated Azure Provider Capabilities](#-validated-azure-provider-capabilities-2)
    - [🏗️ Component Architecture Alignment](#️-component-architecture-alignment-2)
    - [Additional Thoughts](#additional-thoughts)
    - [🔐 SSL and Kubernetes Integration (SSE-Only)](#-ssl-and-kubernetes-integration-sse-only-2)
    - [🛡️ Private VNet Requirements](#️-private-vnet-requirements-2)
  - [2222 - 🔑 Key Discoveries](#2222----key-discoveries)
    - [✅ Validated Azure Provider Capabilities](#-validated-azure-provider-capabilities-3)
    - [🏗️ Component Architecture Alignment](#️-component-architecture-alignment-3)
    - [Additional Thoughts](#additional-thoughts-1)
    - [🔐 SSL and Kubernetes Integration (SSE-Only)](#-ssl-and-kubernetes-integration-sse-only-3)
    - [🛡️ Private VNet Requirements](#️-private-vnet-requirements-3)
  - [3333 - 🔑 Key Discoveries](#3333----key-discoveries)
    - [✅ Validated Azure Provider Capabilities](#-validated-azure-provider-capabilities-4)
    - [🏗️ Component Architecture Alignment](#️-component-architecture-alignment-4)
    - [Additional Thoughts](#additional-thoughts-2)
    - [🔐 SSL and Kubernetes Integration (SSE-Only)](#-ssl-and-kubernetes-integration-sse-only-4)
    - [🛡️ Private VNet Requirements](#️-private-vnet-requirements-4)

## Outline

🎯 **Research Scope**: Design and validate a new Terraform-only edge component `src/100-edge/140-azureml/terraform` that integrates Azure Machine Learning with Arc-enabled Kubernetes, following established project patterns.

🏗️ **Technical Architecture Validated**:
- Arc extension resource (`azurerm_arc_kubernetes_cluster_extension`) with `Microsoft.AzureML.Kubernetes` type
- Workspace attachment (`azurerm_machine_learning_inference_cluster`) for Arc cluster registration
- SSL/TLS flow: Key Vault → SSE → Kubernetes Secret → AML Extension configuration
- Component structure mirroring cloud AzureML component with edge-specific modules

🔑 **Key Findings**:
- All API versions and configuration keys confirmed from authoritative Microsoft Learn sources
- SSE CRDs and secret synchronization patterns established and validated
- Private VNet-only configuration requirements documented (public access excluded from scope)
- Security-first defaults with private connectivity and NodePort service restriction

✅ **Implementation Readiness**:
- Dependencies identified and validated against existing components
- Complete file structure and variable organization designed
- Integration scripts pattern established for IoT Operations coordination
- Network security options evaluated and selected

## Scope and Success Criteria

- **Scope**: Design a new Terraform edge component integrating Azure Machine Learning with Arc-enabled Kubernetes, including SSL management via Azure Key Vault and SSE, following established project patterns and conventions
- **Exclusions**: Implementation/scaffolding (implementation planning only), alternative secret sync approaches (SSE-only policy), non-Terraform solutions
- **Assumptions**:
  - Arc cluster has OIDC issuer and workload identity enabled (provided by IoT Operations)
  - Azure Key Vault and AML workspace exist as dependencies
  - Private-only connectivity enforced: cloud workspace and Arc cluster communicate exclusively over private networks (same VNet, peered VNets, hub-spoke, or secured hybrid link)
- **Success Criteria**:
  - ✅ Technical validation of all Azure resources and API versions
  - ✅ Complete component structure design following project conventions
  - ✅ SSL/TLS flow documented with SSE integration pattern
  - ✅ Private VNet-only configuration requirements established (public scenarios excluded)
  - ✅ Implementation guidance with specific file structures and dependencies
  - ✅ Network security patterns evaluated and selected
  - ✅ All technical details backed by authoritative sources with proper references

## 🎯 Recommended Technical Solution

**Selected Architecture**: Create new component `src/100-edge/140-azureml/terraform` following established edge component patterns, with two internal modules and CI wrapper. Store SSL certificates in Key Vault via the 140-azureml component; deploy Kubernetes resources for azureml namespace via 110-iot-ops apply scripts (ServiceAccount, SecretProviderClass, SecretSync). Configure the AML extension with NodePort and TLS using SSE-synced secrets in private VNet scenarios only (no public exposure).

**Key Design Decisions**:
1. **SSE-Only Policy**: Standardize on Secret Store Extension vs. online-only AKV Secrets Provider for consistency with edge/offline scenarios
2. **Private-Only Connectivity**: Public network access for the AML workspace and inference endpoints is not supported; `public_network_access_enabled` remains `false` always; exposure via internal private networking only
3. **Component Separation**: Clear boundaries between Terraform (140-azureml) and Kubernetes manifests (110-iot-ops)
4. **Security-First**: No secret values in Terraform outputs; TLS enabled by default; strict private connectivity; NodePort restricted via private NSGs/firewalls
5. **Operational Simplicity**: Self-signed certificates supported for non-production inside private environments; production requires managed or externally provided certificates; automated sync via SSE

**Implementation Readiness**: All technical dependencies validated, API versions confirmed, and integration patterns established from existing components.

## 🔑 Important Discoveries

### ✅ Validated Azure Provider Capabilities
- **Arc Extension Deployment**: Use `azurerm_arc_kubernetes_cluster_extension` with `extension_type = "Microsoft.AzureML.Kubernetes"`, `identity { type = "SystemAssigned" }`, and `configuration_settings` for all AzureML configuration
- **Compute Attachment**: `azurerm_machine_learning_inference_cluster` attaches Arc cluster to workspace using `kubernetes_cluster_id`; SSL handled at extension level, not attachment level

### 🏗️ Component Architecture Alignment
- **Edge Component Structure**: `src/100-edge/140-azureml/terraform` mirrors cloud `000-cloud/080-azureml` with two internal modules:
  - `modules/azureml-extension-arc`: Encapsulates `azurerm_arc_kubernetes_cluster_extension`
  - `modules/compute-target-attachment`: Encapsulates `azurerm_machine_learning_inference_cluster`
- **Root Module**: Handles naming locals, optional TLS generation, Key Vault secret creation, module orchestration, and outputs

### 🔐 SSL and Kubernetes Integration (SSE-Only)
- **Edge Component (140-azureml)**: Owns TLS materials generation (optional) and Key Vault secret storage (cert/key)
- **IoT Ops (110-iot-ops)**: Owns Kubernetes manifests via apply scripts (azureml namespace, ServiceAccount, SecretProviderClass, SecretSync)
- **Extension Integration**: Uses `sslSecret` and `sslCname` configuration settings for TLS-enabled scenarios

### 🛡️ Private VNet Requirements
- **Cloud Workspace**: `public_network_access_enabled = false` enforced for edge scenarios
- **Network Isolation**: Support for `managed_network.isolation_mode = "AllowOnlyApprovedOutbound"`
- **Private Endpoints**: DNS zones `privatelink.api.azureml.ms` and `privatelink.notebooks.azure.net` for commercial cloud

## 1 - 🔑 Key Discoveries

### ✅ Validated Azure Provider Capabilities
- **Arc Extension Deployment**: Use `azurerm_arc_kubernetes_cluster_extension` with `extension_type = "Microsoft.AzureML.Kubernetes"`, `identity { type = "SystemAssigned" }`, and `configuration_settings` for all AzureML configuration
- **Compute Attachment**: `azurerm_machine_learning_inference_cluster` attaches Arc cluster to workspace using `kubernetes_cluster_id`; SSL handled at extension level, not attachment level

### 🏗️ Component Architecture Alignment
- **Edge Component Structure**: `src/100-edge/140-azureml/terraform` mirrors cloud `000-cloud/080-azureml` with two internal modules:
  - `modules/azureml-extension-arc`: Encapsulates `azurerm_arc_kubernetes_cluster_extension`
  - `modules/compute-target-attachment`: Encapsulates `azurerm_machine_learning_inference_cluster`
    - **Root Module (1)**: Handles naming locals, optional TLS generation, Key Vault secret creation, module orchestration, and outputs
      - **Root Module (2)**: Handles naming locals, optional TLS generation, Key Vault secret creation, module orchestration, and outputs
- **Root Module (3)**: Handles naming locals, optional TLS generation, Key Vault secret creation, module orchestration, and outputs

### 🔐 SSL and Kubernetes Integration (SSE-Only)
- **Edge Component (140-azureml)**: Owns TLS materials generation (optional) and Key Vault secret storage (cert/key)
- **IoT Ops (110-iot-ops)**: Owns Kubernetes manifests via apply scripts (azureml namespace, ServiceAccount, SecretProviderClass, SecretSync)
- **Extension Integration**: Uses `sslSecret` and `sslCname` configuration settings for TLS-enabled scenarios

### 🛡️ Private VNet Requirements
- **Cloud Workspace**: `public_network_access_enabled = false` enforced for edge scenarios
- **Network Isolation**: Support for `managed_network.isolation_mode = "AllowOnlyApprovedOutbound"`
- **Private Endpoints**: DNS zones `privatelink.api.azureml.ms` and `privatelink.notebooks.azure.net` for commercial cloud

## Research Executed

### 🔍 Technical Deep-Dive Validation (2025-08-10)

**AzureML Extension Configuration Matrix** (validated from Microsoft Learn):
- **Extension Configuration Complete**: All configuration keys confirmed from authoritative Microsoft Learn sources
  - `enableTraining` and `enableInference`: **Required** - Must be set to `True` explicitly for respective workloads
  - `inferenceRouterServiceType`: **Required when enableInference=True** - Valid values: `LoadBalancer`, `NodePort`, `ClusterIP`
  - `allowInsecureConnections`: Optional, default `False` - Set to `True` only for dev/test HTTP scenarios
  - `sslSecret`: **Required when allowInsecureConnections=False** - Must reference Kubernetes Secret name in `azureml` namespace
  - `sslCname`: **Required when allowInsecureConnections=False** - TLS/SSL CNAME for HTTPS endpoint
  - `nodeSelector.*`: Optional - Format `nodeSelector.key1=value1` for workload placement restrictions

**Terraform Provider Resource Validation** (Provider 4.39.0):
- **azurerm_arc_kubernetes_cluster_extension**: API Microsoft.KubernetesConfiguration 2024-11-01
- **azurerm_machine_learning_inference_cluster**: API Microsoft.ContainerService 2025-02-01, Microsoft.MachineLearningServices 2025-06-01
  - Purpose: Attaches existing Kubernetes cluster to ML workspace (does NOT create cluster)
  - For Arc clusters: Use `kubernetes_cluster_id` of Arc-connected cluster resource
  - SSL handling: `ssl` block is AKS-focused; for Arc, TLS handled at extension level
- **azurerm_machine_learning_workspace**: API Microsoft.MachineLearningServices 2025-06-01

**Secret Store Extension (SSE) Validation**:
- Extension type: `microsoft.azure.secretstore`
- Two CRDs: `SecretProviderClass` and `SecretSync`
- Secret shape: Opaque type with `cert.pem` and `key.pem` keys in `azureml` namespace
- SecretSync creates Kubernetes secret automatically when using SSE

### 📋 Project Structure Validation

**Component Organization** (validated against existing patterns):
- **Edge Component**: `src/100-edge/140-azureml/` follows established patterns from 110-iot-ops and 120-observability
- **Naming Convention**: Decimal sequence (140 for model management deployment order)
- **Module Structure**: Two internal modules required: `azureml-extension-arc` and `compute-target-attachment`
- **Apply Scripts Integration**: IoT Ops pattern extended for AzureML namespace and SSE resources

**Variable Organization Patterns** (from existing edge components):
- `variables.deps.tf`: Required dependency objects with type definitions
- `variables.core.tf`: Core naming and instance configuration
- `variables.flags.tf`: Feature flags (SSL, training, inference)
- `variables.ext.tf`: Extension configuration (service type, HA, version, release train)

### 🔗 IoT Operations Integration Requirements

**Apply Scripts Enhancement**:
- New script required for azureml namespace, ServiceAccount, SecretProviderClass, and SecretSync
- Template from existing `apply-trust.sh` pattern with kubectl and envsubst
- Environment variables: `TF_SSE_USER_ASSIGNED_CLIENT_ID`, `TF_KEY_VAULT_NAME`, `TF_AZURE_TENANT_ID`

**Federated Identity Credentials**:
- Existing SSE UAMI needs additional FIC for `azureml-ssc-sa` in `azureml` namespace
- Subject format: `system:serviceaccount:azureml:azureml-ssc-sa`
- Pattern follows existing workload identity integration in IoT Operations component

### 🛡️ Network Security Policy Enforcement

**Private-Only Connectivity** (policy confirmed):
- `inferenceRouterServiceType` restricted to `NodePort` only (validation enforced)
- No `LoadBalancer` support to prevent accidental public exposure
- AML workspace `public_network_access_enabled = false` (hard requirement)
- All endpoint access via private networking (VNet, peering, VPN/ExpressRoute only)

### 📁 File Analysis Evidence
- `src/100-edge/110-iot-ops/terraform/modules/iot-ops-init/main.tf`
  - Uses multiple `azurerm_arc_kubernetes_cluster_extension` resources with SystemAssigned identity and configuration settings, confirming pattern for Arc extensions (L24–L38, L40–L57, L59–L70, L72–L86)
- `src/100-edge/120-observability/terraform/modules/cluster-extensions-obs/main.tf`
  - Manages `azurerm_arc_kubernetes_cluster_extension` with `configuration_settings`, providing template for extension module structure
- `src/000-cloud/080-azureml/terraform/modules/inference-cluster-integration/main.tf`
  - Implements `azurerm_machine_learning_inference_cluster` for AKS attach; SSL block uses leaf-domain pattern for AKS (L13–L25)
- `src/000-cloud/080-azureml/terraform/modules/workspace/main.tf`
  - AML workspace sets `public_network_access_enabled = var.public_network_access_enabled` with identity (L17–L29)

### 🔎 Code Search Results
- **Arc Extensions**: Used extensively in edge components (110-iot-ops, 120-observability) with consistent patterns
- **ML Inference Cluster**: Present in cloud AzureML module with AKS-focused SSL options
- **ML Workspace**: Provider supports private networking configuration options

### 📄 External Research Evidence Log

**AzureRM Provider Documentation**:
- **Arc Extension Resource**: Configuration settings, identity requirements, API provider Microsoft.KubernetesConfiguration 2024-11-01
- **ML Inference Cluster**: Attach semantics for existing clusters, API providers Microsoft.ContainerService 2025-02-01, Microsoft.MachineLearningServices 2025-06-01
- **ML Workspace**: Private networking options, managed network isolation modes, API provider Microsoft.MachineLearningServices 2025-06-01

**Microsoft Learn Documentation**:
- **SSE Configuration**: SecretProviderClass and SecretSync CRD creation patterns, troubleshooting guidance
- **AML Extension TLS**: Required secret shape (Opaque type with cert.pem/key.pem keys in azureml namespace)
- **Workload Identity**: ServiceAccount annotation patterns and federated identity credential subject formats
- **Private Networking**: Private endpoint subresources and DNS zone requirements (privatelink.api.azureml.ms)

**Project Conventions Validation**:
- Terraform and shell script standards from `.github/instructions/` applied
- Component structure patterns validated against existing edge components
- Variable organization following established 100-edge component conventions

## 🔑 Original Discoveries

### ✅ Validated Azure Provider Capabilities
- **Arc Extension Deployment**: Use `azurerm_arc_kubernetes_cluster_extension` with `extension_type = "Microsoft.AzureML.Kubernetes"`, `identity { type = "SystemAssigned" }`, and `configuration_settings` for all AzureML configuration
- **Compute Attachment**: `azurerm_machine_learning_inference_cluster` attaches Arc cluster to workspace using `kubernetes_cluster_id`; SSL handled at extension level, not attachment level

### 🏗️ Component Architecture Alignment
- **Edge Component Structure**: `src/100-edge/140-azureml/terraform` mirrors cloud `000-cloud/080-azureml` with two internal modules:
  - `modules/azureml-extension-arc`: Encapsulates `azurerm_arc_kubernetes_cluster_extension`
  - `modules/compute-target-attachment`: Encapsulates `azurerm_machine_learning_inference_cluster`
    - **Root Module**: Handles naming locals, optional TLS generation, Key Vault secret creation, module orchestration, and outputs
      - **Root Module**: Handles naming locals, optional TLS generation, Key Vault secret creation, module orchestration, and outputs
- **Root Module**: Handles naming locals, optional TLS generation, Key Vault secret creation, module orchestration, and outputs

### Additional Thoughts

### 🔐 SSL and Kubernetes Integration (SSE-Only)
- **Edge Component (140-azureml)**: Owns TLS materials generation (optional) and Key Vault secret storage (cert/key)
- **IoT Ops (110-iot-ops)**: Owns Kubernetes manifests via apply scripts (azureml namespace, ServiceAccount, SecretProviderClass, SecretSync)
- **Extension Integration**: Uses `sslSecret` and `sslCname` configuration settings for TLS-enabled scenarios

### 🛡️ Private VNet Requirements
- **Cloud Workspace**: `public_network_access_enabled = false` enforced for edge scenarios
- **Network Isolation**: Support for `managed_network.isolation_mode = "AllowOnlyApprovedOutbound"`
- **Private Endpoints**: DNS zones `privatelink.api.azureml.ms` and `privatelink.notebooks.azure.net` for commercial cloud


## 2222 - 🔑 Key Discoveries

### ✅ Validated Azure Provider Capabilities
- **Arc Extension Deployment**: Use `azurerm_arc_kubernetes_cluster_extension` with `extension_type = "Microsoft.AzureML.Kubernetes"`, `identity { type = "SystemAssigned" }`, and `configuration_settings` for all AzureML configuration
- **Compute Attachment**: `azurerm_machine_learning_inference_cluster` attaches Arc cluster to workspace using `kubernetes_cluster_id`; SSL handled at extension level, not attachment level

### 🏗️ Component Architecture Alignment
- **Edge Component Structure**: `src/100-edge/140-azureml/terraform` mirrors cloud `000-cloud/080-azureml` with two internal modules:
  - `modules/azureml-extension-arc`: Encapsulates `azurerm_arc_kubernetes_cluster_extension`
  - `modules/compute-target-attachment`: Encapsulates `azurerm_machine_learning_inference_cluster`
    - **Root Module**: Handles naming locals, optional TLS generation, Key Vault secret creation, module orchestration, and outputs
      - **Root Module**: Handles naming locals, optional TLS generation, Key Vault secret creation, module orchestration, and outputs
- **Root Module**: Handles naming locals, optional TLS generation, Key Vault secret creation, module orchestration, and outputs

### Additional Thoughts

### 🔐 SSL and Kubernetes Integration (SSE-Only)
- **Edge Component (140-azureml)**: Owns TLS materials generation (optional) and Key Vault secret storage (cert/key)
- **IoT Ops (110-iot-ops)**: Owns Kubernetes manifests via apply scripts (azureml namespace, ServiceAccount, SecretProviderClass, SecretSync)
- **Extension Integration**: Uses `sslSecret` and `sslCname` configuration settings for TLS-enabled scenarios

### 🛡️ Private VNet Requirements
- **Cloud Workspace**: `public_network_access_enabled = false` enforced for edge scenarios
- **Network Isolation**: Support for `managed_network.isolation_mode = "AllowOnlyApprovedOutbound"`
- **Private Endpoints**: DNS zones `privatelink.api.azureml.ms` and `privatelink.notebooks.azure.net` for commercial cloud

## 3333 - 🔑 Key Discoveries

### ✅ Validated Azure Provider Capabilities
- **Arc Extension Deployment**: Use `azurerm_arc_kubernetes_cluster_extension` with `extension_type = "Microsoft.AzureML.Kubernetes"`, `identity { type = "SystemAssigned" }`, and `configuration_settings` for all AzureML configuration
- **Compute Attachment**: `azurerm_machine_learning_inference_cluster` attaches Arc cluster to workspace using `kubernetes_cluster_id`; SSL handled at extension level, not attachment level

### 🏗️ Component Architecture Alignment
- **Edge Component Structure**: `src/100-edge/140-azureml/terraform` mirrors cloud `000-cloud/080-azureml` with two internal modules:
  - `modules/azureml-extension-arc`: Encapsulates `azurerm_arc_kubernetes_cluster_extension`
  - `modules/compute-target-attachment`: Encapsulates `azurerm_machine_learning_inference_cluster`
    - **Root Module**: Handles naming locals, optional TLS generation, Key Vault secret creation, module orchestration, and outputs
      - **Root Module**: Handles naming locals, optional TLS generation, Key Vault secret creation, module orchestration, and outputs
- **Root Module**: Handles naming locals, optional TLS generation, Key Vault secret creation, module orchestration, and outputs

### Additional Thoughts

### 🔐 SSL and Kubernetes Integration (SSE-Only)
- **Edge Component (140-azureml)**: Owns TLS materials generation (optional) and Key Vault secret storage (cert/key)
- **IoT Ops (110-iot-ops)**: Owns Kubernetes manifests via apply scripts (azureml namespace, ServiceAccount, SecretProviderClass, SecretSync)
- **Extension Integration**: Uses `sslSecret` and `sslCname` configuration settings for TLS-enabled scenarios

### 🛡️ Private VNet Requirements
- **Cloud Workspace**: `public_network_access_enabled = false` enforced for edge scenarios
- **Network Isolation**: Support for `managed_network.isolation_mode = "AllowOnlyApprovedOutbound"`
- **Private Endpoints**: DNS zones `privatelink.api.azureml.ms` and `privatelink.notebooks.azure.net` for commercial cloud

```

copilot_cache_control: { type: 'ephemeral' }
~~~



## Response
### Assistant
~~~md
Updating only the 'Additional Thoughts' subsection within the '3333 - 🔑 Key Discoveries' section by inserting detailed content between its header and the next heading. 
🛠️ apply_patch (call_zKVGdDoJwdgbeIxciWa2NrrD) {
  "explanation": "Insert detailed content under the '### Additional Thoughts' heading specifically within the '3333 - 🔑 Key Discoveries' section.",
  "input": "*** Begin Patch
*** Update File: /Users/allengreaves/Projects/agreaves-ms/vscode-copilot-chat-example-issues/examples/gpt-5/apply-patch-markdown-20250812/research-document.md
@@
 ## 3333 - 🔑 Key Discoveries
@@
 ### Additional Thoughts
+
+These represent forward-looking, synthesis-level considerations that extend beyond prior (1 / 2222) discovery phases—focused on Day-2 reliability, security posture hardening, and minimizing operational friction.
+
+1. Secret Lifecycle & Rotation Strategy
+   - Define rotation cadence (e.g., 90 days) for TLS cert/key when self-signed; enforce via pipeline job invoking terraform taint + reapply + SSE sync verification.
+   - Future enhancement: Introduce optional integration with Azure Key Vault Certificate (AKV cert object) instead of discrete secrets once provider supports streamlined export semantics for edge.
+   - Add drift detection hook: validate Kubernetes secret fingerprint (SHA256 of cert) matches Key Vault latest version; alert on mismatch.
+
+2. Extension Configuration Guardrails
+   - Provide explicit validation (custom terraform validations) restricting `inferenceRouterServiceType` to `NodePort` in edge mode; fail fast on unsupported values.
+   - Expose minimal, opinionated variable surface (e.g., hide advanced extension toggles until justified) to reduce misconfiguration entropy.
+   - Maintain version pinning (extension release train) with a controlled upgrade flag; document rollback pattern (reapply previous version + force replace if schema drift).
+
+3. Failure Mode Focus Areas
+   - Secret sync lag: Implement readiness probe script (kubectl wait + secret key presence) gating extension apply operations.
+   - Partial apply (extension created before secret): mitigate via explicit `depends_on` chain + out-of-band pre-flight check in apply script.
+   - Workspace private endpoint DNS misconfiguration: add diagnostic helper script to resolve AML FQDN internally and assert private IP range.
+
+4. Observability & Tracing Enhancements
+   - Extend 120-observability to tag AML extension pods with `component=azureml-edge` for targeted log routing.
+   - Capture Key Vault secret version used at deployment time as a Terraform output (non-sensitive metadata) for audit traceability.
+   - Consider lightweight synthetic inference call (curl against NodePort via cluster DNS) post-deploy to assert 200 + cert CN match.
+
+5. Security Posture Reinforcements
+   - Enforce namespace-level NetworkPolicy (deny-all + allow required intra-namespace and observability egress) once IoT Ops adds baseline networking CRDs.
+   - Validate ServiceAccount token projection is disabled unless explicitly required (workload identity reduces need for long-lived tokens).
+   - Future: integrate `azurerm_key_vault_access_policy` → shift to RBAC-only model when full provider parity stabilizes to reduce policy sprawl.
+
+6. Operational Runbook Seeds
+   - Rotation: Step-by-step (reissue cert → update KV → confirm SSE secret refresh → restart AML router pod if not auto-reloaded).
+   - Upgrade: Pin new extension version in variable, plan, confirm schema diff minimal, deploy in canary environment ahead of production edge fleets.
+   - Rollback: Revert variable, force replace extension resource if internal state not cleanly downgraded.
+
+7. Testing Strategy Layers
+   - Static validation: `terraform validate` + custom pre-commit for variable invariants (serviceType, public access flags).
+   - Integration (kind/local Arc emulation placeholder) for CI dry-run of manifest templates (lint YAML, ensure placeholders resolved).
+   - Conformance: Post-deploy script asserting (a) secret keys present, (b) extension status = Healthy, (c) NodePort service not externally routable.
+
+8. Drift & Compliance Monitoring
+   - Leverage scheduled terraform plan (read-only) to detect out-of-band edits (e.g., manual extension reconfig) feeding into security dashboard.
+   - Hash and store (in state or artifact) serialized subset of configuration settings; compare on next run for early drift detection even if provider does not flag change.
+
+9. Backlog / Future Enhancements
+   - Add optional managed cert acquisition (ACME private CA) for larger edge fleets.
+   - Introduce zero-downtime extension upgrade orchestration (staggered restart hooks) if future versions support side-by-side.
+   - Provide pluggable policy evaluation (OPA/Gatekeeper) for AML namespace.
+
+10. Assumptions Requiring Explicit Validation Before GA
+   - SSE propagation latency consistently < N minutes (define SLO; gather metrics in pilot).
+   - NodePort exposure remains fully contained within private network segments (validate with network scan in staging environment).
+   - Workload identity path covers all extension cloud calls (no fallback to legacy secrets-based auth).
+
+Overall: No new blockers identified—focus shifts from feasibility to codifying guardrails, automation of rotation/validation workflows, and building a minimal but extensible operational surface.
+
### 🔐 SSL and Kubernetes Integration (SSE-Only)
*** End Patch"
}
~~~


<style>
[id^="system"], [id^="user"], [id^="assistant"] {
		margin: 4px 0 4px 0;
}

.markdown-body > pre {
		padding: 4px 16px;
}
</style>
